<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
        <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>What is Category Theory? | Yehonathan Sharvit</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="What is Category Theory?" />
<meta name="author" content="Yehonathan Sharvit" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="What is Category Theory?" />
<meta property="og:description" content="What is Category Theory?" />
<meta property="og:site_name" content="Yehonathan Sharvit" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-09-10T04:11:22+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="What is Category Theory?" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@Yehonathan Sharvit" />
<script type="application/ld+json">
{"url":"/clojure/2019/09/10/category-theory-part-1.html","@type":"BlogPosting","headline":"What is Category Theory?","dateModified":"2019-09-10T04:11:22+00:00","datePublished":"2019-09-10T04:11:22+00:00","author":{"@type":"Person","name":"Yehonathan Sharvit"},"mainEntityOfPage":{"@type":"WebPage","@id":"/clojure/2019/09/10/category-theory-part-1.html"},"description":"What is Category Theory?","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    

    <!-- Site Favicon -->
    <link rel="shortcut icon" href="/assets/favicon2.png" type="image/png" />

    <!-- Font Embed Code -->
	<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400i,600,600i|Karla:400,400i,700,700i" rel="stylesheet">

    <!-- CSS Styles -->
    <link href="/assets/css/style.css" rel="stylesheet">
</head>



<body class="layout-post">
    <div id="page" class="site">
        <header id="masthead" class="site-header">
    <div class="site-header-wrap">
        <div class="site-header-inside">

            <div class="site-branding">
                
                <p class="profile">
                    <a href="/">
                        <img src="/assets/images/authorimage.jpg" alt="'s Picture"
                            class="avatar" />
                    </a>
                </p>
                <div class="site-identity">
                    
                    <h1 class="site-title">
                        <a href="/">Yehonathan Sharvit</a>
                    </h1>
                    
                    
                    <p class="site-description">Developer. Author. Speaker.</p>
                    
                </div><!-- .site-identity -->
                
                <button id="menu-toggle" class="menu-toggle"><span class="screen-reader-text">Main Menu</span><span
                        class="icon-menu" aria-hidden="true"></span></button>
            </div><!-- .site-branding -->

            <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">
                <div class="site-nav-wrap">
                    <div class="site-nav-inside">
                    <ul class="menu">
                        
                        
                        
                        <li class="menu-item "><a href="/">Blog</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/talks">Talks</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/about">About</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/contact">Contact Me</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/search">Search</a></li>
                        
                    </ul>
                    <p class="social-links">
    <a class="github-button" href="https://github.com/viebel/klipse" data-color-scheme="no-preference: dark; light: dark; dark: dark;" data-show-count="true" aria-label="Star viebel/klipse on GitHub"></a>
<script async defer src="https://buttons.github.io/buttons.js"></script>

    
    <a href="https://twitter.com/viebel" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    
    
    
    
    
    
    <a href="https://www.linkedin.com/in/viebel" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
</p>

                    <div class="book-header">
  <div>
    Discover my book!
  </div>
  <a href="https://www.manning.com/books/data-oriented-programming?utm_source=viebel&utm_medium=affiliate&utm_campaign=book_sharvit2_data_1_29_21&a_aid=viebel&a_bid=d5b546b7" style="text-decoration: none;">
    <img src="/assets/dop-book.png">
  </a>
  <div>
    50% DISCOUNT CODE: DOP50
  </div>
</div>

                    </div><!-- .site-nav-inside -->
                </div><!-- .site-nav-wrap -->
            </nav><!-- .site-navigation -->

        </div><!-- .site-header-inside -->
    </div><!-- .site-header-wrap -->
</header><!-- .site-header -->

        <div id="content" class="site-content fadeInDown delay_075s">
            <div class="inner-wide">
                <main id="main" class="site-main">

    <article class="post-full inner">

        <header class="post-header">
            <div class="post-meta">
                <time class="post-date" datetime="2019-09-10">
                    September 10, 2019
                </time>
            </div><!-- .post-meta -->
            <h1 class="post-title">What is Category Theory?</h1>
            
        </header><!-- .post-header -->

        
        <div class="post-content">
            <p><strong>Yehonathan (The Novice)</strong>:
Hello Mr. Peschanski. Coud you briefly explain what is category theory and why it might be interesting for me? See, I am so curious, there are so many topics I find interesting.</p>

<p><strong>M. Peschanski (The Expert)</strong>: 
First, I suggest you call me <strong>Senpai</strong> and I will then call you <strong>Kohai</strong> rather than <strong>The Novice</strong> (or Yehonathan for that matter).
Briefly, a Kohai may not be a novice and a Senpai is just a little bit more knowledgeable about the concerned topic, and also maybe a little bit older.</p>

<p><strong>Kohai</strong>:
I like those Japanese terms that convey deep ideas. So, Senpai would you please let me know why should I care about category theory more than any other interesting topic?</p>

<p><strong>Senpai</strong>:
I have suggested category theory because it is a very abstract area of mathematics, and for good or bad reasons it has some good or bad impact on programming. Since our common concern is programming (especially programming in Clojure, sorry for the javascript or Python crowd) I find it a good topic. But I have to be a little bit egoistic here. I am not a fan of category theory, and to understand precisely why or alternatively to change my point of view, I think I have to learn more about it, to try to make it more concrete… 
This is important, I am not an expert in the field, knowledgeable is all I am.  So in a way, I ask you to help me Kohai. But the most important bit is that I really think with this topic we can share our understanding through a lot of programming and a bit of abstract mathematics, rather than the converse.</p>

<p>Instead of telling you precisely what is category theory (I simply cannot), I have to start with explaining what is a category. And for this I need a programming environment.</p>

<p>Kohai, here’s now my question for you:</p>
<ul>
  <li>do you know how we may continue our correspondence in a literate programming environment?
I know you are the developer of <a href="https://github.com/viebel/klipse">Klipse</a>, so you are the most knowledgeable here!</li>
</ul>

<p><strong>Kohai</strong>: 
I am honoured Senpai, to be asked a question by you. 
Here is my gift of interactivity fo you:</p>

<pre><code class="language-klipse">(str "Hello " "Senpai!")
</code></pre>

<p><strong>Senpai</strong>:
This is great gift Kohai, I shall use it with care and dedication.
So…</p>

<blockquote>
  <p>What is a <strong>Category</strong>?</p>
</blockquote>

<p>Well, I shall begin to answer when there is some support for latex …</p>

<p><strong>Kohai</strong>: Are you seeking, Senpai, to write simple lambda terms with their greek symbol? Simple terms like \(\lambda x.x\)? I hope that you are not willing to confuse my mind too much with complicated math concepts like Riemann’s Zeta function?</p>

\[\zeta(s) = \sum_{n=1}^{\infty} \frac{1}{n^s}\]

<p><strong>Senpai</strong>: Oh oh, I like these… but I will try not to abuse them. Well let’s begin. First, Kohai, I need to start with a graph. The graph must be relatively small (5, 6 vertices), it must be directed also (edges are arrows). Well, let me explain what I need by code.</p>

<pre><code class="language-klipse">(def my-graph  {:a #{:b :d}
                :b #{:e}
                :c #{:b}
                :d #{:e}
                :e #{}})
</code></pre>

<p>Do you see what I mean? It may be another graph, but that’s a good starting point.</p>

<p><strong>Kohai</strong>: My mind <em>sees</em>  what you mean, dear Senpai. But, my eyes need to <em>visualize</em> the graph. With Klipse, it’s quite simple to <em>visualize</em> a graph, assuming that you allow me to use the popular JSON format, instead of the powerful - but not so popular - EDN format.</p>

<pre><code class="language-eval-js">   var defaultGraphOptions = {
  style: [ 
    {
      selector: 'node',
      style: {
        'background-color': '#666',
        'label': 'data(id)'
      }
    },

    {
      selector: 'edge',
      style: {
        'width': 2,
        'line-color': '#ccc',
        'target-arrow-color': '#ccc',
        'curve-style': 'bezier',
        'target-arrow-shape': 'triangle',
        "label": "data(label)"
      }
    }
  ],

  layout: {
    name: 'circle'
  },
  userZoomingEnabled: false,
  userPanningEnabled: false,
  boxSelectionEnabled: false,
};
</code></pre>

<pre><code class="language-klipse"> (def ^:dynamic *default-graph-options* js/defaultGraphOptions)
</code></pre>

<pre><code class="language-eval-js">var cy = cytoscape({
  ...cljs.user._STAR_default_graph_options_STAR_,
  container: document.getElementById('graph-1'), 
  elements: [ 
    { 
      data: { id: 'a' }
    },
    { 
      data: { id: 'b' }
    },
    { 
      data: { id: 'c' }
    },
    { 
      data: { id: 'd' }
    },
    { 
      data: { id: 'e' }
    },
    { 
      data: { id: 'ab', source: 'a', target: 'b' }
    },
    { 
      data: { id: 'ad', source: 'a', target: 'd' }
    },
    {
      data: { id: 'be', source: 'b', target: 'e' }
    },
    { 
      data: { id: 'cb', source: 'c', target: 'b' }
    },
    {
      data: { id: 'de', source: 'd', target: 'e' }
    }
  ],
})
</code></pre>

<div id="graph-1" style="width: 100%; height: 200px; background-color: white;">
</div>

<p><strong>Senpai</strong>: that’s my graph for sure … but Kohai, what if I want to generate of transform graphs using Clojure programs? Through programs we shall see the light, Kohai!</p>

<p><strong>Kohai</strong>: Through invisible functions, we create the light, Senpai. In a invisible html element just below, I have created a Clojure function named <code class="language-plaintext highlighter-rouge">cytoscape-clj</code> that receives a vector of elements and the id of container where to render the graph.</p>

<pre style="visibility: hidden; height: 0px;">
<code class="language-klipse">
(defn cytoscape-clj [elements container-id]
  (js/cytoscape
   (clj-&gt;js (merge (js-&gt;clj *default-graph-options*)
                   {:container (js/document.getElementById container-id)
                    :elements elements})))
  nil)
 </code>
 </pre>

<pre><code class="language-klipse"> (def elements [{:data {:id "a"}}
               {:data {:id "b"}}
               {:data {:id "c"}}
               {:data {:id "d"}}
               {:data {:id "e"}}
               {:data {:id "ab" :source "a" :target "b"}}
               {:data {:id "ad" :source "a" :target "d"}}
               {:data {:id "be" :source "b" :target "e"}}
               {:data {:id "cb" :source "c" :target "b"}}
               {:data {:id "de" :source "d" :target "e"}}])
 (cytoscape-clj elements "graph-2")
</code></pre>

<div id="graph-2" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Now, dear Senpai, enlightened by the invisible <code class="language-plaintext highlighter-rouge">cytoscape-clj</code> function, you are free to manipulate the elements of the graph as you wish.</p>

<pre><code class="language-klipse"> (cytoscape-clj (take 6 elements) "graph-3")
</code></pre>

<div id="graph-3" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Will you agree at this point, Senpai, to start sharing with a humble creature like me the secrets of the Category Theory <strong>without</strong> any further introduction?</p>

<p><strong>Senpai</strong>: How neat! I like this very much… Let me see… It shouldn’t be too hard to write a Clojure function that converts the adjacency matrix of a graph to its cytoscape elements. After all, it’s all about data manipultion.</p>

<pre><code class="language-klipse">(defn graph-to-elements [g]
  (let [verts (mapv (fn [n] {:data {:id (name n)}}) (keys g))]
    (reduce (fn [els [src tgts]]
              (into els
                    (map (fn [tgt]
                           {:data {:id (str (name src) (name tgt))
                                   :source (name src)
                                   :target (name tgt)}})
                         tgts)))
            verts g)))
            
(defn showgraph [g id]
  (cytoscape-clj (graph-to-elements g) id))
</code></pre>

<pre><code class="language-klipse">(showgraph my-graph "my-graph")
</code></pre>

<div id="my-graph" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Excellent, now I have what I wanted (Klipse is so cool!)… So let’s take our graph, and can you Kohai:</p>

<ol>
  <li>For each vertex, add a “self-loop”, i.e. a directed edge with source and target the very same vertex?</li>
  <li>If e.g. <code class="language-plaintext highlighter-rouge">a</code> goes to <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">b</code> goes to <code class="language-plaintext highlighter-rouge">c</code>, then add a directed edge from <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">c</code>, and do that “everywhere possible” in the graph?</li>
</ol>

<p>That’s two <strong>exercises</strong> . If you find an exercise hard, I’ll try to give you hints, and ultimately I’ll give a solution (if I have one). If you find an exercise boring, please tell me, I’ll wipe it out!</p>

<p><strong>Kohai</strong>: I am so honoured by such a compliment coming from you, respected Senpai, regarding my work on Klipse.</p>

<p>I don’t understand the connection between those exercises and Category Theory, but I will put my impatience aside for now and behave as a disciplined Kohai and reaffirm my trust on your way of teaching, respected Senpai, by working on those exercises.</p>

<p>The first exercise looks to me pretty easy, when we represent a graph through its ajacency matrix:</p>

<pre><code class="language-klipse">my-graph
</code></pre>

<p>In order to add a self-loop to a vertex, I am going to add the vertex itself to its set of neighbours. To code it in Clojure, I  will map each  <code class="language-plaintext highlighter-rouge">neighbours</code> set  to <code class="language-plaintext highlighter-rouge">(conj  neighbours vertex)</code>. I have a Clojure library of my own, named <a href="http://viebel.github.io/gadjett/index.html">gadjett</a> that provides a util function  <a href="http://viebel.github.io/gadjett/gadjett.collections.html#var-map-object-kv">map-object-with-key</a> that makes this kind of manipulations straightforward:</p>

<pre><code class="language-klipse">(require '[gadjett.collections :as coll])

(defn add-self-loops [graph]
  (coll/map-object-with-key 
   (fn [vertex neighbours]
     (conj neighbours vertex))
   graph))
</code></pre>

<p>And now, with the help of the <code class="language-plaintext highlighter-rouge">show-graph</code> function that you kindly wrote, respected Senpai, I can visually confirm thay my <code class="language-plaintext highlighter-rouge">add-self-loop</code> function works as required:</p>

<pre><code class="language-klipse">(showgraph 
 (add-self-loops my-graph)
 "graph-with-self-loops")
</code></pre>

<div id="graph-with-self-loops" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>I am satisfied with my success on the first exercise.</p>

<p>May I ask a hint for solving the second exercise, respected Senpai?</p>

<p><strong>Senpai</strong>: Using the standard library, I would write something like the following:</p>

<pre><code class="language-klipse">(into {} (map (fn [[src tgts]] [src (conj tgts src)]) my-graph))
</code></pre>

<p>But that’s a bit of a mouthful and I like that you show me tricks from you own toolbox Kohai, please do not stop at all. I think there is a nice alternative name for your function: <code class="language-plaintext highlighter-rouge">map-kv</code>  (in the spirit of <code class="language-plaintext highlighter-rouge">reduce-kv</code>).</p>

<p>And now, Kohai, here is my hint for you:</p>

<pre><code class="language-klipse">(showgraph (update my-graph :a #(conj % :e)) "my-graph-hint")
</code></pre>

<div id="my-graph-hint" style="width: 100%; height: 200px; background-color: white;">
</div>

<p><strong>Kohai</strong>: From now on, I shall use <code class="language-plaintext highlighter-rouge">map-kv</code>, as I learned during my initiation that proper naming is essential to good programming. 
I cannot find a way to use your hint, Senpai, but after some new thinking I come with a possible solution to the second exercise. My idea is to map each set of neighbours to the union of:</p>
<ol>
  <li>itself</li>
  <li>the neighbours of each vertex in the set</li>
</ol>

<p>using again <code class="language-plaintext highlighter-rouge">map-kv</code>:</p>

<pre><code class="language-klipse">(require '[clojure.set :refer [union]])

(def map-kv coll/map-object-with-key)
(defn add-paths [graph]
  (map-kv
   (fn [v neighbours]
      (apply union #{v} neighbours (map graph neighbours)))
   graph)) 
</code></pre>

<pre><code class="language-klipse">(showgraph (add-paths my-graph) "my-graph-paths")
</code></pre>

<div id="my-graph-paths" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>My code seems to work, but it looks to me a bit complicated. Is there a way to simplify the code, respected Senpai?</p>

<p><strong>Senpai</strong>: The thing is, you’re not quite there but this is my fault, my example was a little bit insufficent.  Let me change it slightly:</p>

<pre><code class="language-klipse">(def my-graph-v2  {:a #{:b }
                   :b #{:c :e}
                   :c #{:b :d}
                   :d #{:e}
                   :e #{}})
</code></pre>

<pre><code class="language-klipse">(showgraph my-graph-v2 "my-graph-v2")
</code></pre>

<div id="my-graph-v2" style="width: 100%; height: 200px; background-color: white;">
</div>

<pre><code class="language-klipse">(showgraph (add-paths my-graph-v2) "my-graph-v2-paths")
</code></pre>

<div id="my-graph-v2-paths" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>The self-loop are not wrong, but I would prefer to avoid them since it is redundant with the first part of the exercise. But there is one edge missing, can you find it? I give you two hints:</p>
<ol>
  <li>start from <code class="language-plaintext highlighter-rouge">a</code></li>
  <li>think about one of the most important and beautiful things in this  world: <strong>recursion</strong>.</li>
</ol>

<p><strong>Kohai</strong>: I can easily get rid of the self-loops by changing a bit the <code class="language-plaintext highlighter-rouge">add-paths</code> function:</p>

<pre><code class="language-klipse">(require '[clojure.set :refer [difference]])

(defn add-simple-paths [graph]
  (map-kv
   (fn [v neighbours]
     (union neighbours 
            (difference 
             (apply union (map graph neighbours))
             #{v})))
   graph)) 
</code></pre>

<pre><code class="language-klipse">(showgraph (add-simple-paths my-graph-v2) "my-graph-v2-simple-paths")
</code></pre>

<div id="my-graph-v2-simple-paths" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>The hints you gave me, Senpai, make me think that <code class="language-plaintext highlighter-rouge">a</code> should also be connected to <code class="language-plaintext highlighter-rouge">d</code> because, in the original graph there exists a path \(a\rightarrow b \rightarrow c \rightarrow d\). However my <code class="language-plaintext highlighter-rouge">add-simple-paths</code> function only adds paths with 2 edges, like \(a\rightarrow b \rightarrow c\).</p>

<p>Hmm…</p>

<p>My function should be able to create length of unlimited paths. I am so scared to lose myself in an infinite maze with this kind of recursive node traversal.</p>

<p><img src="https://media.mnn.com/assets/images/2014/06/snakes.jpg" alt="maze" /></p>

<p>The tone of your voice is so quiet, respected Senpai. It gives me the confidence and the courage to take some distance from my fears and to look for a simple solution.</p>

<p><em>The Kohai takes a deep breath and enters in a meditation state for about 30 minutes, as he was taught by his Senpai in a previous lesson.</em></p>

<p><em>After 30 minutes, the kohai gently opens his eyes and goes back to his computer…</em></p>

<p>I need to find a way to <em>stabilize</em> <code class="language-plaintext highlighter-rouge">add-simple-paths</code> in the sense that when I call it again, the graph will stay unchanged. In other words, I need to write a function <code class="language-plaintext highlighter-rouge">add-paths-recursively</code> such that <code class="language-plaintext highlighter-rouge">(add-paths-recursively (add-paths-recursively g))</code> is the same as <code class="language-plaintext highlighter-rouge">(add-paths-recursively g)</code>.</p>

<p>I think I can achieve this <em>stability</em> by calling <code class="language-plaintext highlighter-rouge">add-simple-paths</code> in a loop until the graph of the next iteration is the same as the graph of the current iteration:</p>

<pre><code class="language-klipse">(defn add-paths-recursively [g]
  (loop [graph g]
    (let [next-graph (add-simple-paths graph)]
      (if (= next-graph graph)
        graph
        (recur next-graph)))))
</code></pre>

<p>I want to check my assertion:</p>

<pre><code class="language-klipse">(= (add-paths-recursively (add-paths-recursively my-graph-v2))
   (add-paths-recursively my-graph-v2))
</code></pre>

<p>Yeah! My assertion is verified. And, visually I see that the edge connecting <code class="language-plaintext highlighter-rouge">a</code> to <code class="language-plaintext highlighter-rouge">d</code> has been added:</p>

<pre><code class="language-klipse">(showgraph (add-paths-recursively my-graph-v2) "my-graph-v2-paths-fixed")
</code></pre>

<div id="my-graph-v2-paths-fixed" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Is that what you had in mind, respected Senpai?</p>

<p><strong>Senpai</strong>: I think it is… But it will be you telling me that. Because it is time, Kohai, for a definition.</p>

<blockquote>
  <p><strong>Definition</strong>: a <strong>category</strong> \(C\) is:</p>

  <ul>
    <li>a collection \(\mathcal{O}\) of <strong>objects</strong></li>
    <li>a collection \(\mathcal{A}\) of <strong>arrows</strong> (a.k.a. <strong>morphisms</strong>) with each arrow \(f\) going from a <strong>source</strong> object \(a\) to a <strong>target</strong> object \(b\), and denoted by \(f:a\rightarrow b\)</li>
  </ul>

  <p>Moreover:</p>

  <ul>
    <li>for any object \(a\) there is an arrow \(Id_a:a\rightarrow a\) called the <strong>identity</strong> of \(a\)</li>
    <li>if there is an arrow \(f:a\rightarrow b\) and an arrow \(g:b \rightarrow c\) then there exists an arrow \(g \circ f:a\rightarrow c\) called the <strong>composition</strong> of \(f\) and \(g\), or more precisely of \(f\) <em>then</em> \(g\)</li>
  </ul>

  <p>While ensuring that the following <strong>category laws</strong> hold:</p>

  <ol>
    <li>the <strong>identitity law</strong>: if \(f:a\rightarrow b\) is an arrow then \(f \circ Id_a = f\) (right identity) and \(Id_b \circ f = f\) (left identity)</li>
    <li>the <strong>associativity law</strong>: if \(f:a\rightarrow b\), \(g:b\rightarrow c\) and \(h:c\rightarrow d\) then \(h\circ(g \circ f) = (h\circ g) \circ f\)</li>
  </ol>

</blockquote>

<p>Sometimes, Kohai, people will tell you - with perhaps a slightly condescending tone - that the definition above is <em>so</em> simple, and that such simplicity is the reason why category theory is so beautiful.
But in my opinion it is <em>not</em> the case, the definition above is not simple at all, even when writing it I was afraid of forgetting something. Also I wonder if things are well articulated. As you will see, later on, there are also many hidden assumptions.</p>

<p>So you might wonder Kohai if a category is not as beautiful as many “categorists” think, is it still a concept worthy of our interest? I would think that “maybe it is”, which is enough an argument for our journey to continue.</p>

<p>And now I have a new question for you:</p>

<blockquote>
  <p>If I take a directed graph such as <code class="language-plaintext highlighter-rouge">my-graph</code>, do you think it is a category?</p>
</blockquote>

<p><strong>Kohai</strong>: In order to give you a proper answer, Senpai, I need to look again at <code class="language-plaintext highlighter-rouge">my-graph</code>:</p>

<pre><code class="language-klipse">(showgraph my-graph "my-graph-again")
</code></pre>

<div id="my-graph-again" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Well, it could be a category if we apply the following “translation”:</p>
<ol>
  <li>The Objects are the vertices</li>
  <li>The Arrows are the edges</li>
  <li>The identity is the self loop</li>
  <li>The composition of arrows is similar to the second exercise that you gave me</li>
</ol>

<p>I would say that a general directed graph is not a category but when we apply <code class="language-plaintext highlighter-rouge">add-paths-recursively</code> to a graph, it becomes a category.
However, I am not quite sure that this is correct as I don’t know how to give meaning to equality of arrows in order to check the category laws:</p>

<blockquote>
  <ol>
    <li>the <strong>identitity law</strong>: if \(f:a\rightarrow b\) is an arrow then \(f \circ Id_a = f\) (right identity) and \(Id_b \circ f = f\) (left identity)</li>
    <li>the <strong>associativity law</strong>: if \(f:a\rightarrow b\), \(g:b\rightarrow c\) and \(h:c\rightarrow d\) then \(h\circ(g \circ f) = (h\circ g) \circ f\)</li>
  </ol>
</blockquote>

<p><strong>Senpai</strong>: First, yes you are right, a graph together with <em>self-loops</em> (as identities) and <em>graph-paths</em> (as compositions) is a good candidate for a category. Before addressing the <em>law</em> question, I will redefine the notion of a category in Clojure. We will only define the <code class="language-plaintext highlighter-rouge">CatFin</code> protocol for <strong>finite categories</strong>. A category is finite if the collections of objects and arrows are finite sets.</p>

<p>First, for me <code class="language-plaintext highlighter-rouge">CatFin</code> is an abstract concept, and Clojure <em>protocols</em> are a good language feature to give an abstraction a proper name.</p>

<pre><code class="language-klipse">(defprotocol CatFin
  "A protocol for finite categories."
  (objects [cat] "the finite set of objects of `cat`")
  (arrows [cat] "the finite set of arrows of `cat`"))
</code></pre>

<p>Moreover, I think we can use anything as an object, although I will only use <em>keywords</em>, such as <code class="language-plaintext highlighter-rouge">:a</code>, <code class="language-plaintext highlighter-rouge">:b</code>, etc. But I need to fix the representation of an arrow somehow and I propose we simply take a pair of two objects, e.g. <code class="language-plaintext highlighter-rouge">[:a :b]</code>.</p>

<p>Then I can define what is an identity arrow for any <code class="language-plaintext highlighter-rouge">CatFin</code>:</p>

<pre><code class="language-klipse">(defn ident 
  "Identity arrow for `obj`."
  [obj]
  [obj obj])
  
(ident :a)
</code></pre>

<p>And I can also define a composition arrow:</p>

<pre><code class="language-klipse">(defn compose
  "Composition arrow of `arr1` and `arr2` in a [[CatFin]]."
  [arr2 arr1]
  (let [[src2 tgt2] arr2
        [src1 tgt1] arr1]
    (when-not (= tgt1 src2)
      (throw (ex-info "Arrows not composable" {:arrow1 arr1
                                               :arrow2 arr2
                                               :mismatch [tgt1 src2]})))
    [src1 tgt2]))
    
(compose [:e :f] [:d :e]) 
</code></pre>

<pre><code class="language-klipse">(compose [:f :e] [:d :e])
</code></pre>

<p>Let me now “prove” the category laws:</p>

<pre><code class="language-klipse">;; left identity
(let [f [:x 'obj]]
  (= (compose (ident 'obj) f) f))
</code></pre>

<pre><code class="language-klipse">;; right identity
(let [g ['obj :y]]
  (= (compose g (ident 'obj)) g))
</code></pre>

<pre><code class="language-klipse">;; Associativity law
(let [f ['x 'y] g ['y 'z] h ['z 'u]]
  (= (compose (compose h g) f)
     (compose h (compose g f))))
</code></pre>

<p>Are you satisfied Kohai with these?</p>

<p><strong>Kohai</strong>: I am bit confused by the <code class="language-plaintext highlighter-rouge">'obj</code> symbol: Why are you sometimes using <code class="language-plaintext highlighter-rouge">:x</code> and <code class="language-plaintext highlighter-rouge">:y</code> for a general object and sometimes <code class="language-plaintext highlighter-rouge">'obj</code>.</p>

<p><strong>Senpai</strong>: Yes, yes, it’s confusing… Since I took <em>keywords</em> as objets, I wanted to have a way to name an <em>arbitrary object</em>. So where I use a quoted symbol, you should imagine that it could be <em>any object</em>. This, way, the laws become universal, in a way. If I replace <code class="language-plaintext highlighter-rouge">'obj</code> by any keyword the law still holds. So <code class="language-plaintext highlighter-rouge">:x</code> is a specific object named <code class="language-plaintext highlighter-rouge">x</code>, while <code class="language-plaintext highlighter-rouge">'x</code> is an arbitrary object. I hope it’s less confusing now…</p>

<p><strong>Kohai</strong>: I see, this is an important clarification, Senpai. 
But in the “proof” of the left-identity law, I would expect both objects to be <em>arbitrary</em>, and to write the proof like this:</p>

<pre><code class="language-klipse">;; left identity
(let [f ['x 'y]]
  (= (compose (ident 'y) f) f))
</code></pre>

<p><strong>Senpai</strong>:  Of course, you’re right! <em>Errare humanum est</em>.
So let me correct myself with right identity:</p>

<pre><code class="language-klipse">;; right identity (fixed)
(let [g ['x 'y]]
  (= (compose g (ident 'x)) g))
</code></pre>

<p><strong>Kohai</strong>: Also, the “right-to-left” ordering is confusing me.</p>

<p><strong>Senpai</strong>: I use the “right-to-left” ordering because it mimics the way function composition works in Clojure. Let me give you an example.</p>

<pre><code class="language-klipse">(letfn [(f [x] (= x :a))
        (g [y] (if y :b :c))
        (h [z] (= z :b))]
  (= (h (g (f :a)))
     ((comp h g f) :a)))
</code></pre>

<p>It is of course the same in mathematics, we would write:</p>

\[h \circ g \circ f (x) = h(g(f(x)))\]

<p>Very often, arrows will be Clojure(script) functions so it is good if we have a similar way of writing compositions, i.e. right-to-left. But I agree it can be a little bit confusing. This is why I think often we prefer the following:</p>

<pre><code class="language-klipse">(letfn [(f [x] (= x :a))
        (g [y] (if y :b :c))
        (h [z] (= z :b))]
  (-&gt; :a (f) (g) (h)))
</code></pre>

<p><strong>Kohai</strong>: Indeed, the notation with thread macro is much more intuitive to me…</p>

<p><strong>Senpai</strong>: Another important remark is that composition is “self-verifying”. It generates an exception if the two arrows of <code class="language-plaintext highlighter-rouge">(compose arr2 arr1)</code> are not composable. The condition we check is that the target of <code class="language-plaintext highlighter-rouge">arr1</code> (the first function to apply) is <em>equal</em> to the source of <code class="language-plaintext highlighter-rouge">arr2</code> (the second function to apply).</p>

<p>This is in fact a very important “hidden assumption” of the definition of a category: we need objets to be comparable for equality. Luckily Clojure(script) is a “pure-functional-first” programming language, so we can compare so many things for equality. By the way, in your <code class="language-plaintext highlighter-rouge">add-paths-recursively</code> you compared whole graphs for equality (although a simple form of equality, not <em>graph isomorphism</em> and we’ll go back to this later on). But in some categories It can be quite a strong assumption to have an equality for objets. So please Kohai remember this: the notion of equality of objects (and thus of arrows) is <em>fundamental</em> although it is relatively hidden in the definition.</p>

<blockquote>
  <p><strong>Equality</strong> is <strong>fundamental</strong></p>
</blockquote>

<p>Let me add two useful utility functions. I will not explain nor comment them but they will be used, and you’ll know why.</p>

<pre><code class="language-klipse">(defn catfin-all-arrows-from [cat obj]
  (filter (fn [[from to]] (= from obj)) (arrows cat)))
</code></pre>

<pre><code class="language-klipse">(defn catfin-graph [cat]
  (reduce (fn [g obj] 
            (assoc g obj 
                   (into #{}
                         (map second (catfin-all-arrows-from cat obj)))))
          {} (objects cat)))
</code></pre>

<p>Now Kohai, I have yet an exercise for you.</p>

<pre><code class="language-klipse">(defrecord GraphCat [graph]
  CatFin
  ;; &lt;TBD&gt;
)
</code></pre>

<p><strong>Question</strong>: Can you complete the definition explaining that any <code class="language-plaintext highlighter-rouge">graph</code> (such as <code class="language-plaintext highlighter-rouge">my-graph</code>) can be seen as a category?</p>

<p><strong>Kohai</strong>: I can try…
Let me look again at <code class="language-plaintext highlighter-rouge">my-graph</code> data representation:</p>

<pre><code class="language-klipse">my-graph
</code></pre>

<p>The objects are the keys of the map:</p>

<pre><code class="language-klipse">(keys my-graph)
</code></pre>

<p>The arrows of <code class="language-plaintext highlighter-rouge">my-graph</code> are the <code class="language-plaintext highlighter-rouge">[vertex neighbour]</code> pairs of the graph obtained by adding self-loops and paths through <code class="language-plaintext highlighter-rouge">add-paths-recursively</code>. In order to list all the arrows of <code class="language-plaintext highlighter-rouge">(add-paths-recursively my-graph)</code>, I will use <em>list comprehension</em>. Fortunately, in Clojure, the <code class="language-plaintext highlighter-rouge">for</code> macro - that provides list comprehension - supports maps:</p>

<pre><code class="language-klipse"> (for [[vertex neighbours] (add-paths-recursively my-graph)
                neighbour neighbours]
            [vertex neighbour])
</code></pre>

<p>Here is my suggestion for <code class="language-plaintext highlighter-rouge">GraphCat</code> record implementation:</p>

<pre><code class="language-klipse">(defrecord GraphCat [graph]
  CatFin
  (objects [cat] 
           "get the finite set of objects of `cat`"
           (keys graph))
  (arrows [cat]
          "get the finite set of arrows of `cat`"
          (for [[vertex neighbours] (add-paths-recursively graph)
                neighbour neighbours]
            [vertex neighbour])))
</code></pre>

<p>Please tell me, respected Senpai, if I have answered correctly to your question.</p>

<p><strong>Senpai</strong>: Let me check …</p>

<pre><code class="language-klipse">(showgraph (catfin-graph (-&gt;GraphCat my-graph)) "my-graph-catfin")
</code></pre>

<div id="my-graph-catfin" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>Well, dear Kohai, I think the self-loops are missing…</p>

<p><strong>Kohai</strong>: Well, that is easy to add self-loops, using the <code class="language-plaintext highlighter-rouge">add-self-loops</code>, I wrote earlier:</p>

<pre><code class="language-klipse">(defrecord GraphCat2 [graph]
  CatFin
  (objects [cat] 
           "get the finite set of objects of `cat`"
           (keys graph))
  (arrows [cat]
          "get the finite set of arrows of `cat`"
          (for [[vertex neighbours] (add-paths-recursively (add-self-loops graph))
                neighbour neighbours]
            [vertex neighbour])))
</code></pre>

<pre><code class="language-klipse">(showgraph (catfin-graph (-&gt;GraphCat2 my-graph)) "my-graph-catfin-2")
</code></pre>

<div id="my-graph-catfin-2" style="width: 100%; height: 200px; background-color: white;">
</div>

<p><strong>Senpai</strong>: Well done, Kohai!
I know that self-loops do not look like really necessary, but you’ll see they play an important role. In particular, each such identity arrow helps to … identify a specific object, and thus we can forget a little bit about the objects by focusing on the arrows only.</p>

<p><strong>Kohai</strong>: It is similar to focusing on the relationships between people and forget about the ego of each one.</p>

<p><em>(Senpai’s face began to light up)</em></p>

<p><strong>Senpai</strong>: There’s something deep about what you just said … Well, at least we have the identity arrows so that oneself is not totally lost. By the way, do you understand now why I defined <code class="language-plaintext highlighter-rouge">catfin-graph</code>? Any (directed) graph is a finite category if you add the self-loops and “all-recursive paths” (we’ll find a better name soon). But the converse is also true, any finite category can be seen as a graph.  Do you know how such a correspondance is named in maths?</p>

<p><strong>Kohai</strong>: An isomorphism?</p>

<p><strong>Senpai</strong>: That’s exactly that! I think there is an interesting isomorphism to explore between:</p>

<ul>
  <li>a finite category, seen as a graph:</li>
</ul>

<pre><code class="language-klipse">(showgraph (catfin-graph (-&gt;GraphCat2 my-graph))
           "my-graph-catfin-again")
</code></pre>

<div id="my-graph-catfin-again" style="width: 100%; height: 200px; background-color: white;">
</div>

<ul>
  <li>and the original graph:</li>
</ul>

<pre><code class="language-klipse">(showgraph my-graph "my-graph-again-again")
</code></pre>

<div id="my-graph-again-again" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>If the first graph is <em>the category</em> itself (represented as a graph), I would like to call the second graph <em>the shape</em> of the category. This is not standard terminology, but I like it very much.</p>

<p><strong>Kohai</strong>: When you say <em>the shape</em> of a finite category <code class="language-plaintext highlighter-rouge">C</code>, do you mean a graph <code class="language-plaintext highlighter-rouge">G</code> with no self loops and no recursive paths such that <code class="language-plaintext highlighter-rouge">(-&gt;GraphCat2 my-graph)</code> equals <code class="language-plaintext highlighter-rouge">C</code>?</p>

<p><strong>Senpai</strong>: Yes Kohai, what I call a shape is without self loops or recursive paths, exactly!</p>

<p><strong>Kohai</strong>: I was thinking about another isomorphism.</p>

<p><strong>Senpai</strong>: Which one?</p>

<p><strong>Kohai</strong>: A correspondance between a finite category and the set of all graphs that have the same closure. By closure, I mean the addition of self-loops and recursive paths. But I am not even sure that this correspondance is  indeed an isomorphism. Can you please tell me, resepected Senpai, what do you think of this correspondance?</p>

<p><strong>Senpai</strong>: Yes Kohai, your correspondance is in fact the generalization of the one I was starting from. Each time you add a “recursive path”, in a way you stay within the same “class” of graphs with the same “closure”. And you can always go “forward”, adding new paths, or “backward” by removing them. So you have an isomorphism at each step, however the two ends are the most interesting:</p>

<ul>
  <li>the “most backward” step is when you don’t have any self-loop or recursive path, what I called a shape</li>
  <li>the “most forward” step is when you have <em>all</em> self-loops and recursive paths, which is the finite category</li>
</ul>

<p>By the way, you used a very important word to explain <em>exactly</em> the phenomenon: <em>closure</em>. We will reuse the word very soon Kohai.</p>

<p>Are you satisfied with my answer, Kohai?</p>

<p><strong>Kohai</strong>: I need to think more about it…
But, while listening to you, respected Senpai, I asked myself whether the shape of a graph was unique. If the shape is not unique, then the correspondance between shapes and closed graphs is not an isomorphism. Are we going to <em>prove</em> that the shape is unique or are we going to <em>assume</em> it for the moment?</p>

<p><strong>Senpai</strong>: I would prefer to talk about “the shape of a finite category” (which is a graph). I think Kohai that the shape indeed is unique, do you have an example of two shapes describing the <em>same</em> finite cateogry?
At least if there is no cycle in the shape, I am <em>sure</em> it’s unique.</p>

<p><strong>Kohai</strong>: I don’t have such an example. 
What makes you be <em>sure</em> that the shape is unique?</p>

<p><strong>Senpai</strong>: I am sure it is unique if the graph has no cycle because it is then a mathematical object I study a lot in my research work: a <em>partial order</em>. But it is a little bit too soon to discuss this, we got distracted…</p>

<p>(A few moments later …)</p>

<p><strong>Senpai</strong>: Probably you anticipated this but I have yet another exercise for you. You know already how to go from a <em>shape</em> to a finite category, but can you do the converse? From the first graph above, I would like to obtain the second one below. In fact, I need two distinct things:</p>

<ol>
  <li>a way to obtain the shape of a finite category</li>
  <li>a way to check that it is <em>indeed</em> a shape</li>
</ol>

<p>For testing your solution, let me give you a more complex (and interesting!) example.</p>

<pre><code class="language-klipse">(def my-sys
  {:init #{:gen :step-1 :fork}
   :gen #{:yield-1}
   :yield-1 #{:yield-2 :step-3}
   :yield-2 #{:end}
   :step-1 #{:load :step-2}
   :load #{:xform}
   :xform #{:step-4}
   :step-2 #{:step-3}
   :step-3 #{:step-4}
   :step-4 #{:end}
   :fork #{:comp-1 :comp-2-1}
   :comp-1 #{:join}
   :comp-2-1 #{:comp-2-2}
   :comp-2-2 #{:join}
   :join #{:end}
   :end #{}})
   
(showgraph my-sys "my-sys")
</code></pre>

<div id="my-sys" style="width: 100%; height: 400px; background-color: white;">
</div>

<p>Please trust me Kohai, this <em>is</em> a shape.</p>

<p><strong>Remark</strong>: the layout of the graph is not optimal… I would rather use the <em>breadthfirst</em> layout, cf. http://js.cytoscape.org/#layouts/breadthfirst
Do you know how we could do that with your almighty Klipse?</p>

<p><strong>Kohai</strong>: Let me create a new function that will allow us to control the cytoscape graph options:</p>

<pre><code class="language-klipse">(defn showgraph-with-options [g id options]
  (binding [*default-graph-options* (clj-&gt;js (merge (js-&gt;clj *default-graph-options*) options))]
  (cytoscape-clj (graph-to-elements g) id)))
</code></pre>

<p>Now, we can visualize the graph you defined with <em>breadthfirst</em> layout:</p>

<pre><code class="language-klipse">(showgraph-with-options my-sys "my-sys-breadthfirst"
                        {:layout {:name "breadthfirst"
                                  :directed true}})
</code></pre>

<div id="my-sys-breadthfirst" style="width: 100%; height: 400px; background-color: white;">
</div>

<p>Does it address your needs, respected Senpai?</p>

<p><strong>Senpai</strong>: Yes! I think it’s much clearer what is the intent of <code class="language-plaintext highlighter-rouge">my-sys</code>, don’t you think? You inspire me a lot of respect Kohai! Are you ready for our little exercise?</p>

<p><strong>Kohai</strong>: Indeed your intent is much clearer now.
I am ready for our exercise. 
Let me start by reflecting upon how one could check that a graph is <em>a shape</em>. I have to check two things:</p>
<ol>
  <li>There are no self-loops</li>
  <li>There are no recursive paths</li>
</ol>

<p>Detecting the absence of self loops seems easy to me as I only need to check that for every node, the node is not a member of the neighbours set:</p>

<pre><code class="language-klipse">(defn no-self-loops? [graph]
  (every? (fn [[node neighbours]]
                   (not (contains? neighbours node)))
                 graph))
</code></pre>

<p>But I have no idea how to check that there are no recursive paths. Would you agree to give me a hint, respected Senpai?</p>

<p><strong>Senpai</strong>: I agree, the exercise is not so easy. If we don’t mind too much about <em>algorithm complexity</em>, we can maybe find a simple solution.</p>

<p>As a starting point, I would say that an edge <code class="language-plaintext highlighter-rouge">[:a :b]</code> is “recursive” (perhaps I would say “redundant”) in a graph <code class="language-plaintext highlighter-rouge">g</code> if I can still go from <code class="language-plaintext highlighter-rouge">:a</code> to <code class="language-plaintext highlighter-rouge">:b</code> in the graph with this edge removed. The following utility function might prove useful:</p>

<pre><code class="language-klipse">(defn reachables
  "Reachable vertices from `v` in graph `g`"
  ([g v] (reachables g #{} v))
  ([g visited v]
   (let [targets (get g v #{})]
     (reduce union 
             targets 
             (map #(reachables g (conj visited v) %)
                  (difference targets visited))))))
</code></pre>

<p>Let’s see with our example graph.</p>

<pre><code class="language-klipse">(def my-catfin-graph (catfin-graph (-&gt;GraphCat2 my-graph)))
(showgraph my-catfin-graph "my-catfin-graph")
</code></pre>

<div id="my-catfin-graph" style="width: 100%; height: 200px; background-color: white;">
</div>

<p>For example, <code class="language-plaintext highlighter-rouge">:e</code> is reachable from <code class="language-plaintext highlighter-rouge">:a</code>:</p>

<pre><code class="language-klipse">(reachables my-catfin-graph :a)
</code></pre>

<p>If I remove the edge <code class="language-plaintext highlighter-rouge">[:a :e]</code>, it seems <code class="language-plaintext highlighter-rouge">:e</code> is still reachable</p>

<pre><code class="language-klipse">(reachables (update my-catfin-graph :a #(disj % :e)) :a)
</code></pre>

<p>Hence <code class="language-plaintext highlighter-rouge">[:a :e]</code> is a recursive/redundant edge, because for example I can follow the path composed of the two edges <code class="language-plaintext highlighter-rouge">[:a :b]</code> and <code class="language-plaintext highlighter-rouge">[:b :e]</code>.</p>

<p>If we compare with the initial graph, <code class="language-plaintext highlighter-rouge">:e</code> is reachable from <code class="language-plaintext highlighter-rouge">:a</code> of course.</p>

<pre><code class="language-klipse">(reachables my-graph :a)
</code></pre>

<p>But there is no such edge <code class="language-plaintext highlighter-rouge">[:a :e]</code>.</p>

<pre><code class="language-klipse">(contains? (my-graph :a) :e)
</code></pre>

<p>… no redundancy!</p>

<p>I think it is a good time to state the following.</p>

<blockquote>
  <p><strong>Reachability</strong> is a fundamental property of directed graphs.</p>
</blockquote>

<p>Do you agree with the following?</p>

<blockquote>
  <p>If a vertex <code class="language-plaintext highlighter-rouge">:e</code> is reachable from a vertex <code class="language-plaintext highlighter-rouge">:a</code> in a shape, then it  will also be reachable in the graph with self-loops and recursive paths.</p>
</blockquote>

<p><strong>Kohai</strong>: I agree with this claim but I think that the other direction of the claim is more interesting:</p>

<blockquote>
  <p>If a vertex <code class="language-plaintext highlighter-rouge">:e</code> is reachable from a vertex <code class="language-plaintext highlighter-rouge">:a</code> in a graph (that might contain self-loops and recursive paths), then it  will also be reachable in the graph with self-loops and recursive paths.</p>
</blockquote>

<p><strong>Senpai</strong>: I think both sides are interesting … reachability is a very robust concept.</p>

<p><strong>Kohai</strong>: The side that you mentioned seems to me trivial for the simple reason that the graph with self-loops and recursive paths in an <em>extension</em> of the original graph. How could it be possible for a vertex <code class="language-plaintext highlighter-rouge">:e</code> to be reachable from a vertex <code class="language-plaintext highlighter-rouge">:a</code> in a graph <code class="language-plaintext highlighter-rouge">G</code> and not in a graph that contains <code class="language-plaintext highlighter-rouge">G</code>?</p>

<p>(Senpai walking in circles …)</p>

<p><strong>Senpai</strong>: Yes Kohai, your argument has valour: this side is rather easy to prove, but it’s <em>still</em> an important and useful property. It is a property that I can decide on a small graph, the shape, and it easily translates to the concept we are studying: a (finite) category.  So let me rephrase the property:</p>

<blockquote>
  <p>A vertex  <code class="language-plaintext highlighter-rouge">:e</code> is reachable from a vertex <code class="language-plaintext highlighter-rouge">:a</code> in a shape if, and only if (<em>iff</em>) there is an arrow <code class="language-plaintext highlighter-rouge">[:a :e]</code>  in the corresponding finite category.</p>
</blockquote>

<p>(Senpai back to a resting position …)</p>

<p><strong>Senpai</strong>: 
Dear Kohai, shall we go back to the exercise?</p>

<p><strong>Kohai</strong>: Well… You told me that for the moment, we can ignore the algorithm complexity. It allows me to think of all kind of ideas, including the most naive ones.
Here is a naive idea that comes to my mind:</p>

<p>I am going to check if there is an edge in the graph that can be removed without impacting the reachability of any pair of nodes in the graph. If such an edge exist, then I would argue that this edge is <em>redundant</em> and therefore the graph in question is not a shape.
What do you think of my naive idea, respected Senpai?</p>

<p><strong>Senpai</strong>: Do you mean that for each node <code class="language-plaintext highlighter-rouge">:a</code> , and for each neighbour (or direct successor) <code class="language-plaintext highlighter-rouge">:b</code> of this node (i.e. <code class="language-plaintext highlighter-rouge">(contains? :b (get graph :a))</code> is <code class="language-plaintext highlighter-rouge">true</code>), check if <code class="language-plaintext highlighter-rouge">:b</code> is still <em>reachable</em> when it is removed from the neighbours/successors of <code class="language-plaintext highlighter-rouge">:a</code>?
(I think <em>neighbour</em> is more an undirected graph concept…).</p>

<p><strong>Kohai</strong>: Exactly, Senpai!
I take the fact that you are taking time to rephrase my idea as an indication that my idea is valuable.
Let me try to code it in Clojure.</p>

<p>First, I need a predicate function that checks whether a successor is redundant, I will call it <code class="language-plaintext highlighter-rouge">redundant-successor?</code>:</p>

<pre><code class="language-klipse">(defn redundant-successor? [graph node successor]
  (or (= node successor)
      (= (reachables graph node)
         (reachables (update graph node #(disj % successor)) node))))
</code></pre>

<p>Now, a graph is a <em>shape</em> if for all the <code class="language-plaintext highlighter-rouge">[node successor]</code> pairs, <code class="language-plaintext highlighter-rouge">(redundant-successor? node successor)</code> is <code class="language-plaintext highlighter-rouge">false</code>. With list comprehension, it’s a piece of cake to code it:</p>

<pre><code class="language-klipse">(defn shape? [graph]
  (every? false? 
          (for [[node successors] graph
                successor successors]
            (redundant-successor? graph node successor))))
</code></pre>

<p>As surprising as it could be, my naive idea and my simple function seem to work properly:</p>

<pre><code class="language-klipse">(map shape? [my-graph my-catfin-graph my-sys])
</code></pre>

<p><strong>Senpai</strong>: This is <em>simple</em> as in <a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>! Very well done, Kohai…</p>

<p>Well, we need one last couple of things, though:</p>

<ul>
  <li>a function <code class="language-plaintext highlighter-rouge">shape-of-catfin</code> that takes a finite category and returns its shape as a graph.</li>
  <li>a function <code class="language-plaintext highlighter-rouge">catfin-of-shape</code> that does the converse (hint! I’ve seen this somewhere, but the name was different…)</li>
</ul>

<p>Remember, I wanted to establish through code that there is an isomorphism between finite categories and their shape. So I would like something like:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">catfin-of-shape</span><span class="w"> </span><span class="p">(</span><span class="nf">shape-of-catfin</span><span class="w"> </span><span class="n">&lt;C&gt;</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">&lt;C&gt;</span><span class="w"> </span><span class="o">~</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">true</span><span class="w">
</span><span class="p">(</span><span class="nf">shape-of-catfin</span><span class="w"> </span><span class="p">(</span><span class="nf">catfin-of-shape</span><span class="w"> </span><span class="n">&lt;G&gt;</span><span class="p">))</span><span class="w"> </span><span class="nb">=</span><span class="w"> </span><span class="n">&lt;G&gt;</span><span class="w"> </span><span class="o">~</span><span class="nb">&gt;</span><span class="w"> </span><span class="n">true</span><span class="w">
</span></code></pre></div></div>

<p><strong>Kohai</strong>: Proving a math theorem via coding is really exciting!</p>

<p>First, I want to write a function that takes a graph and returns its shape:</p>

<pre><code class="language-klipse">(defn shape-of-graph [graph]
  (map-kv (fn [node successors]
            (into #{} 
                  (remove (partial redundant-successor? graph node)
                          successors)))
          graph))
</code></pre>

<p>And to implement <code class="language-plaintext highlighter-rouge">shape-of-catfin</code>, I just need to convert the catfin to a graph and then call <code class="language-plaintext highlighter-rouge">shape-of-graph</code>:</p>

<pre><code class="language-klipse">(defn shape-of-catfin [catfin]
  (shape-of-graph (catfin-graph catfin)))
</code></pre>

<p>For <code class="language-plaintext highlighter-rouge">catfin-of-shape</code>, I think it’s exactly the same as instantiating a <code class="language-plaintext highlighter-rouge">GraphCat2</code>, since a shape is a graph:</p>

<pre><code class="language-klipse">(defn catfin-of-shape [shape]
  (GraphCat2. shape))
</code></pre>

<p>Now, let’s check whether the two sides of the isomorphism hold.</p>

<p>From a <em>catfin</em> to its <em>shape</em> and back to its <em>catfin</em>:</p>

<pre><code class="language-klipse">(def my-catfin (GraphCat2. my-graph))
(= (catfin-of-shape (shape-of-catfin my-catfin))
   my-catfin)
</code></pre>

<p>From a <em>shape</em> to its <em>catfin</em> and back to its <em>shape</em>:</p>

<pre><code class="language-klipse">(def my-shape my-graph)
(= (shape-of-catfin (catfin-of-shape  my-shape))
    my-shape)
</code></pre>

<p>The isomorphism holds!</p>

<p><strong>Senpai</strong>: Wonderful! However what we did, Kohai, is to <em>construct</em> an isomorphism rather than prove it. But at least we have a witness of the fact, which is already a good thing.</p>

<p><strong>Kohai</strong>: I am so grateful, respected Senpai, that you initiated me to the wonders of mathematical proofs via programming.</p>

<p><em>(The Senpai and the Kohai celebrate the initiation of the Kohai, by drinking 17 glasses of water…)</em></p>

<p><em>(After the celebration, illuminated by the power of the 17 glasses of water, the Kohai comes to the Senpai…)</em></p>

<p><strong>Kohai</strong>: I don’t know why, but I feel a spirit of skepticism invading my mind: Now, I am asking myself how much this proof is really valid mathematically. After all, we have only proved the isomorphism for a specific graph. Are we going to check it programatically for <em>all</em> the possible graphs? It will take forever….</p>

<p><strong>Senpai</strong>: Of course we cannot prove the fact in this way, but a fact it is. What we could do is to try to find a counter-example, if only by enumerating shapes. Or we could use <a href="https://github.com/latte-central/LaTTe">LaTTe</a> and work a few more weeks to obtain a formal proof in Clojure… But this would distract us from where we are now, and where we are going <em>from</em> now. So let me summarize our current situation.</p>

<ul>
  <li>we have the definition of a category with objects and arrows,</li>
  <li>a finite category (with finite sets of objects and arrows) is akin to a directed graph with all self-loops and recursive paths</li>
  <li>we constructed and witnessed an isomorphism between what I called the <em>shape</em> of a finite category and the finite category itself, which consists in removing self-loops and recursive paths.</li>
</ul>

<p>We are almost <em>there</em> but I would like to introduce one more mathematical concept. Do you know <em>kohai</em> the definition of a <strong>partially ordered set</strong> (or <strong>poset</strong>)? You can of course consult Wikipedia if you wish!</p>

<p><strong>Kohai</strong>: I learned about <strong>posets</strong> at University during an introductory course to Mathematical Sets. If my memory doesn’t delue me, a poset is a set with a relation of order between <strong>some</strong> of its elements. A relation of order \(\leqslant\) is a relation that is:</p>
<ol>
  <li><strong>reflexive</strong>: for every element \(X\) of the poset,  \(X \leqslant X\)</li>
  <li><strong>transitive</strong>: for every elements \(X\) and \(Y\), if \(X \leqslant Y\) and \(Y \leqslant Z\), then \(X \leqslant Z \)</li>
  <li><strong>antisymmetric</strong>: there is no distinct elements \(X\) and \(Y\) such that both \(X \leqslant Y\) and \(Y \leqslant X\)</li>
</ol>

<p>Let me try to guess what is your intent, respected Senpai….
Representing a poset as a graph where the relation of order between two nodes corresponds to the existence of an edge between the nodes. 
I can see that:</p>
<ol>
  <li>The existence of self loops ensure the reflexivity.</li>
  <li>The existence of recursive paths ensure the transitivity.</li>
</ol>

<p><strong>Senpai</strong>: Yes! a directed graph can be seen as a poset, but only if it is <em>acyclic</em>  (well, let’s say that the longest cycle you allow is a self-loop). Soon Kohai you will not need me anymore.</p>

<p><strong>Kohai</strong>: The clarity of your teachings, respected Senpai, is what allows me to progress quickly and safely in the path of my initiation to Category Theory.</p>

<p>But what about the antisymmetric property?</p>

<p><strong>Senpai</strong>: that is an <em>excellent</em> question. In fact, you had me think <em>a lot</em> about it!</p>

<p>(Senpai navigated the internet for days in the look of an interesting answer)</p>

<p>And I reckon I have some elements of answer…</p>

<p>First, if we take a directed <em>acyclic</em> graph (DAG) then antisymmetry holds by construction because you simply cannot have both an edge from \(X\) to \(Y\) and another one from \(Y\) to \(X\) with \(X\) and \(Y\) distinct vertices because this would form a cycle in the graph. So acyclicity and antisymmetry are tightly related.</p>

<p>Technically speaking, the objets and arrows of a category form a <em>preorder</em> if we consider an object \(a\) to be “less than” an object \(b\) if there is an arrow \(a \rightarrow b\).</p>
<ul>
  <li>we have reflexivity because for each object \(a\) we have an identity arrow \(a \rightarrow a\)</li>
  <li>we have transitivity thanks to arrow composition (if there is an arrow \(a \rightarrow b\) and an arrow \(b \rightarrow c\) then we have an arrow \(a \rightarrow c\)).</li>
</ul>

<p>However the category conditions do not impose antisymmetry. Only if we further add the constraint, then we have a poset. Taking the problem upside-down, any poset can be seen as a category with the extra property of antisymmetry. And if we have antisymmetry, we have acyclicity in the directed graph <em>representation</em>. We are a little bit distracted here, but that’s a very interesting distraction.</p>

<p>(after a few weaks of reflecting, and investigating, the matter …)</p>

<p>A category which assumes that isomorphic objects are in fact equal is called a <strong>skeletal category</strong>. In many situations this further “hidden” assumption is in fact omnipresent so we must be careful. Equality strikes again!</p>

<p><strong>Kohai</strong>: I am bit confused by the term <em>representation</em> and by the fact that you mention <em>preorders</em>. Are we dealing with DAG or with Directed Graphs?</p>

<p><strong>Senpai</strong>: Yes, yes, I confess this is somewhat confusing. The point is that the objects and arrows of a category form a preorder <em>by definition</em>. Moreover, for the finite case, this is representable as a directed graph. So we are dealing with directed graphs. However, if what we want is a poset, thus also antisymmetry, then in the representation we have a directed <em>acyclic</em> graph. Well, at least the <em>shape</em> is acyclic and that’s the thing I am interested in: representing a (finite) category by its shape.</p>

<p>So why am I talking about the <em>representation</em> of a finite category as a directed graph, alternatively the <em>representation</em> of a poset-as-a-finite-category as a DAG?</p>

<p>This is because there may be some structure in the objects and the arrows of the category, e.g. the objects are sets and the arrows are functions between sets (we will go back to this example in the second part of our study). In the graph I have only vertices and directed edges, no structure “inside”. That is why I talk about <em>the</em> shape of a finite category, and that is also why I am talking about <em>representation</em> or <em>shape</em>.</p>

<p><strong>Kohai</strong>: (silence …)</p>

<p><strong>Senpai</strong>: Do you agree with the following?</p>

<blockquote>
  <p>Any finite category whose shape is acyclic is (also) a <em>preorder</em>. And this is complete: any <em>preorder</em> can be represented by an acyclic shape (which is called its <em>covering</em>). Thus, a (finite) poset <em>is</em> a (finite) category.</p>
</blockquote>

<p><strong>Kohai</strong>: Well, if the shape is acyclic, then I would say that it is an <em>order</em> and not only a <em>preorder</em>…</p>

<p><strong>Senpai</strong>: Yes! This is an overlook from my part, I have to rephrase:</p>

<blockquote>
  <p>Any finite category is (also) a <em>preorder</em> and is representable by a directed graph, its <em>shape</em>. Moreover if it is antisymmetric then is is a poset and representable as a DAG, its <em>acyclic shape</em>. And this is complete: any <em>preorder</em> (resp. <em>poset</em>) can be represented by a shape (resp. acyclic shape, which is called its <em>covering</em>).</p>
</blockquote>

<p>… or something like that… Well I don’t remember well why I wanted to say this, but I know that posets are interesting things!</p>

<p><strong>Kohai</strong>: (silence, again …)</p>

<p><strong>Senpai</strong>: All we need to know is wether a given shape is <em>acyclic</em> or not… Could you implement such a test? (yes, yes, Kohai, that’s one more exercise for you). As a witness, I would think that <code class="language-plaintext highlighter-rouge">my-graph-v2</code> above is not a poset, unlike the other graphs, in particular <code class="language-plaintext highlighter-rouge">my-sys</code>.</p>

<p><strong>Kohai</strong>: I enjoy very much your exercises, respected Senpai, as they allow me to integrate your teachings, to make them <em>mine</em>, in a sense…</p>

<p>Detecting the absence of any cycle in a graph is really easy when we use your <code class="language-plaintext highlighter-rouge">reachables</code> function. We only need to check no node is reachable from itself!</p>

<pre><code class="language-klipse">(defn acyclic? [graph]
  (let [nodes (keys graph)]
    (every? (fn [node]
              (not (contains? (reachables graph node) node)))
            nodes)))
</code></pre>

<p>Indeed <code class="language-plaintext highlighter-rouge">my-graph-v2</code> is not acyclic:</p>

<pre><code class="language-klipse">(acyclic? my-graph-v2)
</code></pre>

<p>While <code class="language-plaintext highlighter-rouge">my-sys</code> is acyclic:</p>

<pre><code class="language-klipse">(acyclic? my-sys)
</code></pre>

<p>Do you have another last exercise for me, Senpai?</p>

<p><strong>Senpai</strong>: Well, dear Kohai, before finishing this first part of our common study, I would like to consider a change of viewpoint. We know that any directed graph (without recursive paths) can be “upgraded” to a finite category by adding all self-loops and all recursive paths. This is the same with acyclic (and intransitive) graphs but then the category we obtain is antisymmetric and is thus (also) a poset.</p>

<p>Now I propose to consider two new and much larger categories. In the first category that I want to call <strong>ShapeCat</strong></p>
<ul>
  <li>the objects are directed graphs (without transitive edges, i.e. recursive paths) or self-loops</li>
  <li>the arrows are <em>graph transformations</em></li>
</ul>

<p>The second category <strong>OrdCat</strong> is the same but with the extra condition that the graphs/shapes are <em>acyclic</em>.</p>

<p>Now the basic <em>graph transformations</em> are:</p>
<ul>
  <li>the insertion/removal of a disconnected vertex</li>
  <li>the insertion of a directed edge between two existing vertices, such that: if the edge is <code class="language-plaintext highlighter-rouge">[:a :b]</code> then these are distinct vertices (otherwise we would have a self-loop) and moreover there is no existing path from <code class="language-plaintext highlighter-rouge">:a</code> to <code class="language-plaintext highlighter-rouge">:b</code> already in the graph (otherwise we would have a transitive edge). In the specific case of <strong>OrdCat</strong> it must also be the case that the new edge does not create a cycle in the graph.</li>
  <li>the removal of an edge from two existing vertices</li>
</ul>

<p>These are your exercises Kohai: a function for any of these basic graph transformations (with examples!). Is this too much work Kohai?</p>

<p>(After a  long week made of short nights, the Kohai comes again to the house of the Senpai, exhausted but proud of himself…)</p>

<p><strong>Kohai</strong>: It was indeed a lot of work, Senpai!</p>

<p>I was able to write 4 functions for the 4 <em>graph transformations</em> that you define. When one of the conditions of the transformation doesn’t hold, the function throw an exception?</p>

<p><strong>Senpai</strong>: that sounds like a decent solution. The transformations are clearly <em>partial</em> functions on graphs and it is an error to attempt a wrong transformation.  Let me see your functions…</p>

<pre><code class="language-klipse">(defn insert-vertex [graph v]
  (if (get graph v)
    (throw (ex-info "The vertex already exists in the graph" {:graph graph
                                                              :vertex v}))
  (assoc graph v #{})))

(insert-vertex {:a #{:b :d}, :b #{}, :c #{:b}, :d #{}, :e #{}} :z)
</code></pre>

<pre><code class="language-klipse">(defn remove-vertex [graph v]
  (if 
    (or 
     (not (get graph v))
     (not (empty? (get graph v)))
     (contains? (into #{} (apply concat (vals graph))) v))
    (throw (ex-info "The vertex is not disconnected or doesn't exist"
             {:graph graph
              :vertex v}))
    (dissoc graph v)))
(remove-vertex {:a #{:b :d}, :b #{}, :c #{:b}, :d #{}, :e #{}} :e)
</code></pre>

<pre><code class="language-klipse">(defn remove-edge [graph [a b]]
  (cond
    (or (not (graph a))
        (not (graph b))) (throw (ex-info "one of the two vertices of the edge doesn't exist" {:edge [a b] :graph graph}))
    (not (contains? (graph a) b)) (throw (ex-info "the edge doesn't exist" {:edge [a b] :graph graph}))
    :else (update graph a #(difference % #{b}))))

(remove-edge {:a #{:b :d}, :b #{:e}, :c #{:b}, :d #{:e}, :e #{}} [:a :b])
</code></pre>

<pre><code class="language-klipse">(defn insert-edge [graph [a b]]
  (cond
    (= a b) (throw (ex-info "the two vertices of the edge are the same" {:edge [a b] :graph graph}))
    (or (not (graph a))
        (not (graph b))) (throw (ex-info "one of the two vertices of the edge doesn't exist" {:edge [a b] :graph graph}))
    (contains? (graph a) b) (throw (ex-info "the edge already exists" {:edge [a b] :graph graph}))
    (contains? (reachables graph a) b) (throw (ex-info "the edge is redundant" {:edge [a b] :graph graph}))
    :else (update graph a #(union % #{b}))))

(insert-edge {:a #{:b :d}, :b #{:e}, :c #{:b}, :d #{:e}, :e #{}} [:c :a])
</code></pre>

<p><strong>Senpai</strong>: That’s good, I think we have the primitive <strong>ShapeCat</strong> arrows. For the <strong>OrdCat</strong> case we should also avoid the creation of a cycle, do you want me to create the <strong>OrdCat</strong> variants?</p>

<p><strong>Kohai</strong>:</p>

<p><strong>Senpai</strong>: Now, we need a way to compose such transformations because we need the composability of arrows in categories.</p>

<p><strong>Kohai</strong>: Please guide me, respected Senpai, through the path of the composition.</p>

<p><strong>Senpai</strong>: I think that a transformation is a function that takes a <em>particular</em> graph (or an acyclic graph) and produces another particular graph. The functions you wrote are thus like “families” of graph transformations. If we “speak” in types, for a transformation “family” \(\phi\) should be something of the form:</p>

\[\phi :: X \times Graph \rightarrow Graph\]

<p>Here (X) is the type of the extra argument, like the vertex you add in  <code class="language-plaintext highlighter-rouge">insert-vertex</code>. Given a <code class="language-plaintext highlighter-rouge">X</code> and a <code class="language-plaintext highlighter-rouge">Graph</code>, and provided that the transformation is possible on this graph, we obtain a resulting <code class="language-plaintext highlighter-rouge">Graph</code>.</p>

<p>Now if we combine with a second transformation “family”:</p>

\[\psi :: Y \times Graph \rightarrow Graph\]

<p>The family of compositions \(\phi\) <em>then</em> \(\psi\) could be a function of the following kind of signature:</p>

\[\rho :: (X \times Y) \times Graph \rightarrow Graph\]

<p>(but an arrow in <strong>ShapeCat</strong> is when the parameters and the input graph are fixed).</p>

<p>Can you compose Kohai ?</p>

<p>(Senpai passes a few days thinking about arrows in graphs …)</p>

<p>Kohai, I have an alternative idea! Of course, we can take a function from a graph to a graph as an arrow in <strong>ShapeCat</strong> or <strong>OrdCat</strong>. But in a way it is not very <em>canonical</em>. How can we be sure that the transformation is possible on the given graph? Moreover, many functions will compute the same transformation, and it is all very <em>opaque</em>  (that is something I have “against” functions, they are not data, you cannot see “through” them).</p>

<p>But what about representing a graph transformation as a pair of graphs:</p>

<ul>
  <li>a <em>negative subgraph</em> \(G^-\) that explains which vertices and edges should be removed</li>
  <li>a <em>positive subgraph</em> \(G^+\) that explain which vertices and edges should (then) be added</li>
</ul>

<p>An extra condition is that these two subgraphs are disjoint.</p>

<p>With this notion, could you explain (maybe in code ?) what would be the identity arrows, and the composition of arrows?
(maybe we should then check that <strong>ShapeCat</strong> and <strong>OrdCat</strong> respectfully agree with the definition of a category).</p>

<p>We would then have reached the end of our first approach to <em>what is a category?</em>, and we would be ready to begin our second encounter!</p>

<p><strong>Kohai</strong>: The new approach seems to me much more enjoyable!
If I understand you correctly, a transformation \(T\) can be represented as a pair \(\langle G_1, G_2 \rangle\) and when we apply \(T\) on a graph \(G\), we get the graph \((G \cup G_1) \setminus G_2\). Is that correct?</p>

<p><strong>Senpai</strong>: I would intuitively say \((G \setminus G_2) \cup G_1\), but it’s interesting to make things commute, i.e. \((G \setminus G_2) \cup G_1 = (G \cup G_1) \setminus G_2\). Undoubtedly, it is not that case in general, there must be some conditions on the graphs. By the way, I would rather denote the transformation by \(\langle G^-,G^+ \rangle\) or something like that. I’m sure there is such a theory somewhere, maybe in <em>graph rewriting</em> but let’s pretend it’s our idea for now!</p>

<p><strong>Kohai</strong>: Back to your question about identity arrow and composition of arrows:
The identity arrow would then be \(\langle \phi,\phi \rangle\), where \(\phi\) is the empty set.</p>

<p>If \(\langle G_1,G_2 \rangle\) and \(\langle H_1,H_2 \rangle\) are two arrows, then the composition of the two arrows is given by: \(\langle G_1 \cup H_1 \setminus G_2,G_2 \cup H_2 \setminus G_1 \rangle\). My idea is that:</p>
<ol>
  <li>The composed positive subgraph is the union of the two positive subgraphs from which we subtract the second negative subgraph</li>
  <li>The composed negative subgraph is the union of the two negative subgraphs from which we subtract the first positive subgraph</li>
</ol>

<p>Am I in the right direction, respected Senpai?</p>

<p><strong>Senpai</strong>: Looks like the right direction… In fact I don’t know and I guess we should try with some code! Do you want to write some code Kohai, or do you want me to write some code for a change? It is for you to decide!</p>

<p><strong>Kohai</strong>: Currently, I am in the middle of a meditation… I am practicing my ability to encompass the existence as a whole. Therfore, I prefer to abandon you the pleasure of filling up the details….</p>

<p><strong>Senpai</strong>: Well, Kohai, in fact we went far beyond what I had in mind for this first step, on the point that we may have a reached a <em>boring point</em> (a point where things start to bore a fellow Clojurian).</p>

<p>In fact, we have plenty enough examples of concrete <strong>categories</strong>:</p>

<ul>
  <li>the abstraction <strong>FinCat</strong> of finite categories</li>
  <li>the isomorphism between <strong>FinCat</strong> and  acyclic direct graphs with no self-loop (the <em>shape</em> of a category)</li>
  <li>the interesting subcategory of (finite) <em>Posets</em> seen as <strong>FinCat</strong>’s</li>
  <li>the change of point of view of considering categories of <em>graph transformations</em> in which objects are graphs and arrows are transformation from graphs to (modified) graphs, let’s call it <strong>GraphCat</strong>.</li>
</ul>

<p>Note that <strong>GraphCat</strong> has an infinite number of objects (all the possible graphs) and arrows (all the possible transformations). However in category this is still considered a <em>small category</em>, Category theory is a very <em>large</em> field of study!</p>

<p>In conclusion, I am quite happy Kohai with this first iteration of our dialogue. We did not go very far in <strong>GraphCat</strong>: we did not build it, and we haven’t checked (even informally) that this is indeed a category. It may come back at some point since <em>graph transformations</em> are quite an interesting topic, but for now we should start thinking about our next dialogue, in which I intend to introduce a much more <em>practical</em> category: <strong>SpecCat</strong> which of course involves the <a href="https://clojure.org/guides/spec">Spec</a> framework!</p>

<p>Curious enough?</p>

<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.3.3/cytoscape.min.js">
</script>

<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


        </div>
        <footer class="post-footer">
          <div class="book-below">
  <div style="float: left; width: 50%;">
    <a href="https://www.manning.com/books/data-oriented-programming?utm_source=viebel&utm_medium=affiliate&utm_campaign=book_sharvit2_data_1_29_21&a_aid=viebel&a_bid=d5b546b7" style="text-decoration: none;">
      <div style="color:black; padding-left: 10px;">
        Change the way you <b>think</b> about writing code.
	      <div style="font-weight: bold;"> Start reading my book today! </div>
        <br>
        <ul>
          <li>
            Unlearn outdated <b>paradigms</b> and embrace the <b>flexibility</b> of a data-first approach with this accessible guide to data-oriented programming.
          </li>

        <li>
        <b>Data-oriented Programming</b> is now available from Manning Publications. Learn how to implement the data-oriented paradigm in traditional object-oriented languages like Java, C# or JavaScript.
        </li>

        <li>
          Powerful new <b>ideas</b> are presented through <i>conversations</i>, <i>code snippets</i>, <i>diagrams</i>, and even <i>songs</i> to help you quickly grok what’s great about DOP.
        </li>
        <li>
          <b>Save 50%</b> on the cover price now through February 15. Use promo code DOP50 during checkout. 
        </li>



        </ul>
      </div>
    </a>
  </div>
  <div style="float: left; width: 50%;">
    <a href="https://www.manning.com/books/data-oriented-programming?utm_source=viebel&utm_medium=affiliate&utm_campaign=book_sharvit2_data_1_29_21&a_aid=viebel&a_bid=d5b546b7" style="text-decoration: none;">
      <img src="/assets/dop-book.png">
    </a>
  </div>
  <div style="clear: both;">
  </div>
</div>

            <div class="post-share">
                <span class="post-share-title">Share:</span>
                <a target="_blank"
                    href="https://twitter.com/share?text=What+is+Category+Theory%3F&amp;url=https://blog.klipse.techclojure/2019/09/10/category-theory-part-1.html">Twitter</a>
                <a target="_blank"
                    href="https://www.facebook.com/sharer/sharer.php?u=https://blog.klipse.techclojure/2019/09/10/category-theory-part-1.html">Facebook</a>
            </div><!-- .share-post -->
        </footer>
    </article>
    
    <section class="newsletter-box inner">
    <h2 class="newsletter-box-title">Subscribe to Yehonathan Sharvit newsletter</h2>
    <p>Get the latest and greatest from Yehonathan Sharvit delivered straight to your inbox every week.</p>
    <!-- Begin TinyLetter Signup Form -->
    <div id="tinyletter_embed_signup">
      <form class="validate gh-subscribe-form" action="https://tinyletter.com/klipse" method="post" target="popupwindow" onsubmit="window.open('https://tinyletter.com/klipse', 'popupwindow', 'scrollbars=yes,width=800,height=600');return true">
	      <label for="tlemail" class="screen-reader-text">Email Address</label>
        <input type="email" value="" name="email" class="required email subscribe-email" placeholder="Your email address">
	      <input type="hidden" value="1" name="embed"/>
	      <input class="button" type="submit" value="Subscribe" />
      </form>
    </div>
    <!--End mc_embed_signup-->
</section><!-- .widget -->

    
    <section class="read-next inner">
        <h2 class="read-next-title">Read Next</h2>
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="May 20, 2019">May 20, 2019</time>
                </div>
                <h3 class="post-title"><a href="/clojure/2019/05/20/type-inference-in-clojurescript.html">The secrets of Type Inference in Clojurescript</a>
                </h3>
                <p class="post-tags">
                    
                </p>
            </header>
        </article>
        
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="September 9, 2020">September 9, 2020</time>
                </div>
                <h3 class="post-title"><a href="/clojure/2020/09/09/core-async-canvas.html">How to draw on a canvas with Klipse and core.async</a></h3>
                <p class="post-tags">
                    
                </p>
            </header>
        </article>
        
    </section><!-- .read-next -->

    <!-- Create a sorted array of tags -->
     
    <section class="tagcloud inner">
        <h2 class="tagcloud-title">Tags</h2>
        <div class="tag-links">
            
            <a href='/tags/#brainfuck'>brainfuck</a>
            
            <a href='/tags/#c%2B%2B'>c++</a>
            
            <a href='/tags/#clojure'>clojure</a>
            
            <a href='/tags/#clojurescript'>clojurescript</a>
            
            <a href='/tags/#javascript'>javascript</a>
            
            <a href='/tags/#kids'>kids</a>
            
            <a href='/tags/#klipse'>klipse</a>
            
            <a href='/tags/#lambda-calculus'>lambda-calculus</a>
            
            <a href='/tags/#php'>php</a>
            
            <a href='/tags/#python'>python</a>
            
            <a href='/tags/#react'>react</a>
            
            <a href='/tags/#reagent'>reagent</a>
            
            <a href='/tags/#ruby'>ruby</a>
            
            <a href='/tags/#scheme'>scheme</a>
            
        </div><!-- .tag-links -->
    </section><!-- .tagcloud -->
</main><!-- .site-main -->


<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/prolog.css">

<script>
    window.klipse_settings = {
        codemirror_options_in: {
            lineWrapping: true,
            autoCloseBrackets: true
        },
        codemirror_options_out: {
            lineWrapping: true
        },
        beautify_strings: true,

        selector: '.language-klipse, .language-eval-clj',
        selector_eval_js: '.language-klipse-eval-js, .language-eval-js, [data-lang=klipse-javascript]',
        selector_jsx: '.language-klipse-jsx',
        selector_prolog_rules: '.language-prolog-rules',
        selector_prolog_query: '.language-prolog-query',
        selector_render_jsx: '.language-render-jsx',
        selector_es2017: '.language-es2017',
        selector_brainfuck: '.language-brainfuck',
        selector_transpile_jsx: '.language-transpile-jsx',
        selector_eval_php: '.language-klipse-eval-php',
        selector_eval_markdown: '.language-klipse-markdown',
        selector_eval_lambdaway: '.language-klipse-lambdaway',
        selector_eval_python_client: '.language-klipse-python, .language-eval-python',
        selector_eval_html: '.language-klipse-html',
        selector_sql: '.language-klipse-sql',
        selector_eval_ruby: '.language-klipse-eval-ruby, .language-eval-ruby',
        selector_eval_scheme: '.language-klipse-scheme, .language-eval-scheme',
        selector_eval_clisp: '.language-klipse-clisp',    
        selector_eval_cpp: '.language-klipse-cpp',
        selector_google_charts: '.language-google-chart',
        selector_plot: '.language-plot',
        selector_oblivion: '.language-oblivion',
        selector_lua: '.language-klipse-lua',
        selector_js: '.language-klipse-js',
        selector_eval_ocaml: '.language-klipse-ocaml',
        selector_transpile_ocaml: '.language-transpile-ocaml',
        selector_transpile_reason_3: '.language-transpile-reason',
        selector_transpile_reason_3_to_ocaml: '.language-transpile-reason-to-ocaml',
        selector_eval_reason_3: '.language-klipse-reason',
        selector_eval_reason_3_with_types: '.language-klipse-reason-types',
        selector_eval_ocaml_with_types: '.language-klipse-ocaml-types',
        selector_ocaml_to_reason: '.language-ocaml-to-reason',
        selector_reagent: '.language-reagent',
    };










    

    


</script>



<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js?v=8.0.1"></script>





                

                
                <footer id="colophon" class="site-footer">
    <p class="site-info inner">
        <a href="#">Yehonathan Sharvit</a> &copy; 2021.
    </p>
    <a id="back-to-top" class="back-to-top" href="#page">
        <span class="icon-arrow-up" aria-hidden="true"></span>
        <span class="screen-reader-text">Back to top</span>
    </a>
</footer><!-- .site-footer -->

            </div><!-- .inner-wide -->
        </div><!-- .site-content -->
    </div><!-- .site -->

    
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-75651930-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-75651930-1', { 'anonymize_ip': true });
  </script>

    <!-- Javascript Assets -->
    <script src="/assets/js/jquery-3.3.1.min.js"></script>
    <script src="/assets/js/custom.js"></script>

</body>

</html>
