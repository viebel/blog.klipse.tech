<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
        <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Interactive overview of Scheme’s semantics | Yehonathan Sharvit</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Interactive overview of Scheme’s semantics" />
<meta name="author" content="Yehonathan Sharvit" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Interactive overview of Scheme’s semantics" />
<meta property="og:description" content="Interactive overview of Scheme’s semantics" />
<meta property="og:site_name" content="Yehonathan Sharvit" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-09-11T04:21:29+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Interactive overview of Scheme’s semantics" />
<meta name="twitter:site" content="@" />
<meta name="twitter:creator" content="@Yehonathan Sharvit" />
<script type="application/ld+json">
{"url":"/scheme/2016/09/11/scheme-tutorial-1.html","headline":"Interactive overview of Scheme’s semantics","dateModified":"2016-09-11T04:21:29+00:00","datePublished":"2016-09-11T04:21:29+00:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/scheme/2016/09/11/scheme-tutorial-1.html"},"author":{"@type":"Person","name":"Yehonathan Sharvit"},"description":"Interactive overview of Scheme’s semantics","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    

    <!-- Site Favicon -->
    <link rel="shortcut icon" href="/assets/favicon2.png" type="image/png" />

    <!-- Font Embed Code -->
	<link href="https://fonts.googleapis.com/css?family=Crimson+Text:400,400i,600,600i|Karla:400,400i,700,700i" rel="stylesheet">

    <!-- CSS Styles -->
    <link href="/assets/css/style.css" rel="stylesheet">
</head>



<body class="layout-post">
    <div id="page" class="site">
        <header id="masthead" class="site-header">
    <div class="site-header-wrap">
        <div class="site-header-inside">

            <div class="site-branding">
                
                <p class="profile">
                    <a href="/">
                        <img src="/assets/images/authorimage.jpg" alt="'s Picture"
                            class="avatar" />
                    </a>
                </p>
                <div class="site-identity">
                    
                    <h1 class="site-title">
                        <a href="/">Yehonathan Sharvit</a>
                    </h1>
                    
                    
                    <p class="site-description">Developer. Author. Speaker.</p>
                    
                </div><!-- .site-identity -->
                
                <button id="menu-toggle" class="menu-toggle"><span class="screen-reader-text">Main Menu</span><span
                        class="icon-menu" aria-hidden="true"></span></button>
            </div><!-- .site-branding -->

            <nav id="main-navigation" class="site-navigation" aria-label="Main Navigation">
                <div class="site-nav-wrap">
                    <div class="site-nav-inside">
                    <ul class="menu">
                        
                        
                        
                        <li class="menu-item "><a href="/">Blog</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/talks">Talks</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/about">About</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/contact">Contact</a></li>
                        
                        
                        
                        <li class="menu-item "><a href="/search">Search</a></li>
                        
                    </ul>
                    <p class="social-links">
    <a class="github-button" href="https://github.com/viebel/klipse" data-color-scheme="no-preference: dark; light: dark; dark: dark;" data-show-count="true" aria-label="Star viebel/klipse on GitHub"></a>
<script async defer src="https://buttons.github.io/buttons.js"></script>

    
    <a href="https://twitter.com/viebel" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
    
    
    
    
    
    
    <a href="https://www.linkedin.com/in/viebel" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
<!--
Font Awesome Free 5.5.0 by @fontawesome - https://fontawesome.com
License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
-->
    </a>
    
    
    
</p>

                    <div class="book-header">
  <div>
    Discover my book!
  </div>
  <a href="https://www.manning.com/books/data-oriented-programming?utm_source=viebel&utm_medium=affiliate&utm_campaign=book_sharvit2_data_1_29_21&a_aid=viebel&a_bid=d5b546b7" style="text-decoration: none;">
    <img src="/assets/dop-book.png">
  </a>
  <div>
    DISCOUNT CODE: sharvit39
  </div>
</div>

                    </div><!-- .site-nav-inside -->
                </div><!-- .site-nav-wrap -->
            </nav><!-- .site-navigation -->

        </div><!-- .site-header-inside -->
    </div><!-- .site-header-wrap -->
</header><!-- .site-header -->

        <div id="content" class="site-content fadeInDown delay_075s">
            <div class="inner-wide">
                <main id="main" class="site-main">

    <article class="post-full inner">

        <header class="post-header">
            <h1 class="post-title">Interactive overview of Scheme's semantics</h1>
            <span class="post-meta">
              <time class="post-date" datetime="2016-09-11">
                September 11, 2016
              </time>
            </span>
            
            <span class="post-tags">
                <a href="/tags/index.html#scheme"
                    rel="tag">scheme</a>
                
            </span>
            
        </header><!-- .post-header -->

        <div class="post-content">
            <h2 id="introduction">Introduction</h2>

<p>Following Algol, Scheme is a statically scoped programming language. Each use of a variable is associated with a lexically apparent binding of that variable.</p>

<p>Scheme has latent as opposed to manifest types. Types are associated with objects (also called values) rather than with variables. (Some authors refer to languages with latent types as untyped, weakly typed or dynamically typed languages.)</p>

<p>Other languages with latent types are Python, Ruby, Smalltalk, and other dialects of Lisp.</p>

<p>Languages with manifest types (sometimes referred to as strongly typed or statically typed languages) include Algol 60, C, C#, Java, Haskell, and ML.</p>

<p>Scheme was one of the first languages to support procedures as objects in their own right. Procedures can be created dynamically, stored in data structures, returned as results of procedures, and so on. Other languages with these properties include Common Lisp, Haskell, ML, Ruby, and Smalltalk.</p>

<p>One distinguishing feature of Scheme is that continuations - which in most other languages only operate behind the scenes - also have “first-class” status. First-class continuations are useful for implementing a wide variety of advanced control constructs, including non-local exits, backtracking, and coroutines.</p>

<p>In Scheme, the argument expressions of a procedure call are evaluated before the procedure gains control, whether the procedure needs the result of the evaluation or not.</p>

<p>C, C#, Common Lisp, Python, Ruby, and Smalltalk are other languages that always evaluate argument expressions before invoking a procedure.</p>

<p>This is distinct from the lazy-evaluation semantics of Haskell, or the call-by-name semantics of Algol 60, where an argument expression is not evaluated unless its value is needed by the procedure.</p>

<p><img src="/assets/everest.jpg" alt="Everest" /></p>

<h2 id="tutorial-through-code-examples">Tutorial through code examples</h2>

<p>All the code snippets of this page are <strong>live</strong> and <strong>interactive</strong> powered by the <a href="https://github.com/viebel/klipse">klipse plugin</a>:</p>

<ol>
  <li><strong>Live</strong>: The code is executed in your browser</li>
  <li><strong>Interactive</strong>: You can modify the code and it is evaluated as you type</li>
</ol>

<p>This tutorial is an interactive adaptation of the <a href="http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-4.html#node_chap_1">Overview of Scheme</a> written by <a href="http://www.r6rs.org">r6rs.org</a>.</p>

<p>The evaluation of scheme code in the browser is powered by <a href="https://github.com/biwascheme/biwascheme">biwascheme</a>.</p>

<h2 id="basic-types">Basic types</h2>

<p>Scheme programs manipulate objects, which are also referred to as values. Scheme objects are organized into sets of values called types. This section gives an overview of the fundamentally important types of the Scheme language. More types are described in later chapters.</p>

<blockquote>
  <p>As Scheme is latently typed, the use of the term type in this report differs from the use of the term in the context of other languages, particularly those with manifest typing.</p>
</blockquote>

<h3 id="booleans">Booleans</h3>

<p>A boolean is a truth value, and can be either true or false. In Scheme, the object for “false” is written #f. The object for “true” is written #t. In most places where a truth value is expected, however, any object different from #f counts as true.</p>

<pre><code class="language-klipse-scheme">#t
</code></pre>

<pre><code class="language-klipse-scheme">#f
</code></pre>

<h3 id="numbers">Numbers</h3>

<p>Scheme supports a rich variety of numerical data types, including objects representing integers of arbitrary precision, rational numbers, complex numbers, and inexact numbers of various kinds.</p>

<h3 id="characters">Characters</h3>

<p>Scheme characters mostly correspond to textual characters. More precisely, they are isomorphic to the scalar values of the Unicode standard.</p>

<pre><code class="language-klipse-scheme">#\a
</code></pre>

<h3 id="strings">Strings</h3>

<p>Strings are finite sequences of characters with fixed length and thus represent arbitrary Unicode texts.</p>

<pre><code class="language-klipse-scheme">"Hello, Scheme"
</code></pre>

<h3 id="symbols">Symbols</h3>

<p>A symbol is an object representing a string, the symbol’s name. Unlike strings, two symbols whose names are spelled the same way are never distinguishable. Symbols are useful for many applications; for instance, they may be used the way enumerated values are used in other languages.</p>

<h3 id="pairs-and-lists">Pairs and lists</h3>

<p>A pair is a data structure with two components. The most common use of pairs is to represent (singly linked) lists, where the first component (the <code class="language-plaintext highlighter-rouge">car</code>) represents the first element of the list, and the second component (the <code class="language-plaintext highlighter-rouge">cdr</code>) the rest of the list. Scheme also has a distinguished empty list, which is the last <code class="language-plaintext highlighter-rouge">cdr</code> in a chain of pairs that form a list.</p>

<pre><code class="language-klipse-scheme">(car '(1 2 3))
</code></pre>
<pre><code class="language-klipse-scheme">(cdr '(1 2 3))
</code></pre>

<h3 id="vectors">Vectors</h3>

<p>Vectors, like lists, are linear data structures representing finite sequences of arbitrary objects. Whereas the elements of a list are accessed sequentially through the chain of pairs representing it, the elements of a vector are addressed by integer indices. Thus, vectors are more appropriate than lists for random access to elements.</p>

<pre><code class="language-klipse-scheme">#(1 2 3)
</code></pre>

<pre><code class="language-klipse-scheme">(vector-ref #(1 2 3) 2)
</code></pre>

<h2 id="expressions">Expressions</h2>

<p>The most important elements of Scheme code are expressions. Expressions can be evaluated, producing a value. The most fundamental expressions are literal expressions:</p>

<pre><code class="language-klipse-scheme">#t
</code></pre>

<pre><code class="language-klipse-scheme">23
</code></pre>

<p>This notation means that the expression #t evaluates to #t, that is, the value for “true”, and that the expression 23 evaluates to a number object representing the number 23.</p>

<p>Compound expressions are formed by placing parentheses around their subexpressions. The first subexpression identifies an operation; the remaining subexpressions are operands to the operation:</p>

<p>In the following expression, <code class="language-plaintext highlighter-rouge">+</code> is the name of the built-in operation for addition, and 23 and 42 are the operands. The expression <code class="language-plaintext highlighter-rouge">(+ 23 42)</code> reads as “the sum of 23 and 42”.</p>

<pre><code class="language-klipse-scheme">(+ 23 42)
</code></pre>

<p>Compound expressions can be nested: the following expression reads as “the sum of 14 and the product of 23 and 42”.</p>

<pre><code class="language-klipse-scheme">(+ 14 (* 23 42))
</code></pre>

<p>As these examples indicate, compound expressions in Scheme are always written using the same prefix notation. As a consequence, the parentheses are needed to indicate structure. Consequently, “superfluous” parentheses, which are often permissible in mathematical notation and also in many programming languages, are not allowed in Scheme.</p>

<p>As in many other languages, whitespace (including line endings) is not significant when it separates subexpressions of an expression, and can be used to indicate structure.</p>

<h3 id="infinity">Infinity</h3>

<p>It is possible to deal a bit with the infinity in Scheme. Here is how we represent the infinity:</p>

<pre><code class="language-klipse-scheme">+inf.0
</code></pre>

<p>Every number is less than <code class="language-plaintext highlighter-rouge">infinity</code>:</p>

<pre><code class="language-klipse-scheme">(&lt; 999999999 +inf.0)
</code></pre>

<p>And when we add a number to <code class="language-plaintext highlighter-rouge">infinity</code>, nothing happens:</p>

<pre><code class="language-klipse-scheme">(= +inf.0 (+ 999 +inf.0))
</code></pre>

<h1 id="variables-and-binding">Variables and binding</h1>

<p>Scheme allows identifiers to stand for locations containing values. These identifiers are called variables. In many cases, specifically when the location’s value is never modified after its creation, it is useful to think of the variable as standing for the value directly.</p>

<pre><code class="language-klipse-scheme">(let ((x 23)
      (y 42))
  (+ x y))
</code></pre>

<p>In this case, the expression starting with let is a binding construct. The parenthesized structure following the let lists variables alongside expressions: the variable <code class="language-plaintext highlighter-rouge">x</code> alongside 23, and the variable <code class="language-plaintext highlighter-rouge">y</code> alongside 42. The let expression binds <code class="language-plaintext highlighter-rouge">x</code> to 23, and <code class="language-plaintext highlighter-rouge">y</code> to 42. These bindings are available in the body of the let expression, <code class="language-plaintext highlighter-rouge">(+ x y)</code>, and only there.</p>

<h1 id="definitions">Definitions</h1>

<p>The variables bound by a let expression are local, because their bindings are visible only in the let’s body. Scheme also allows creating top-level bindings for identifiers as follows:</p>

<pre><code class="language-klipse-scheme">(define x 23)
(define y 42)

(+ x y)
</code></pre>

<p>The first two parenthesized structures are definitions; they create top-level bindings, binding <code class="language-plaintext highlighter-rouge">x</code> to 23 and <code class="language-plaintext highlighter-rouge">y</code> to 42. Definitions are not expressions, and cannot appear in all places where an expression can occur. Moreover, a definition has no value.</p>

<pre><code class="language-klipse-scheme">(define c 123)
</code></pre>

<p>Bindings follow the lexical structure of the program: When several bindings with the same name exist, a variable refers to the binding that is closest to it, starting with its occurrence in the program and going from inside to outside, and referring to a top-level binding if no local binding can be found along the way:</p>

<pre><code class="language-klipse-scheme">(define x 23)
(define y 42)

(let ((y 43))
  (+ x y))
</code></pre>

<pre><code class="language-klipse-scheme">(let ((y 43))
  (let ((y 44))
    (+ x y)))
</code></pre>

<h1 id="forms">Forms</h1>

<p>While definitions are not expressions, compound expressions and definitions exhibit similar syntactic structure:</p>

<pre><code class="language-klipse-scheme">(define x 23)
(* x 2)
</code></pre>

<p>While the first line contains a definition, and the second an expression, this distinction depends on the bindings for <code class="language-plaintext highlighter-rouge">define</code> and <code class="language-plaintext highlighter-rouge">*</code>. At the purely syntactical level, both are forms, and form is the general name for a syntactic part of a Scheme program. In particular, 23 is a subform of the form <code class="language-plaintext highlighter-rouge">(define x 23)</code>.</p>

<h1 id="procedures">Procedures</h1>

<p>Definitions can also be used to define procedures:</p>

<pre><code class="language-klipse-scheme">(define (f x)
  (+ x 42))

(f 23)
</code></pre>

<p>A procedure is, slightly simplified, an abstraction of an expression over objects. In the example, the first definition defines a procedure called <code class="language-plaintext highlighter-rouge">f</code>. (Note the parentheses around <code class="language-plaintext highlighter-rouge">f x</code>, which indicate that this is a procedure definition.) The expression <code class="language-plaintext highlighter-rouge">(f 23)</code> is a procedure call, meaning, roughly, “evaluate <code class="language-plaintext highlighter-rouge">(+ x 42)</code> (the body of the procedure) with <code class="language-plaintext highlighter-rouge">x</code> bound to 23”.</p>

<p>As procedures are objects, they can be passed to other procedures:</p>

<pre><code class="language-klipse-scheme">(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23)
</code></pre>

<p>In this example, the body of <code class="language-plaintext highlighter-rouge">g</code> is evaluated with <code class="language-plaintext highlighter-rouge">p</code> bound to <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">x</code> bound to 23, which is equivalent to <code class="language-plaintext highlighter-rouge">(f 23)</code>, which evaluates to 65.</p>

<p>In fact, many predefined operations of Scheme are provided not by syntax, but by variables whose values are procedures. The <code class="language-plaintext highlighter-rouge">+</code> operation, for example, which receives special syntactic treatment in many other languages, is just a regular identifier in Scheme, bound to a procedure that adds number objects. The same holds for <code class="language-plaintext highlighter-rouge">*</code> and many others:</p>

<pre><code class="language-klipse-scheme">(define (h op x y)
  (op x y))

(h + 23 42)
</code></pre>

<pre><code class="language-klipse-scheme">(h * 23 42)
</code></pre>

<p>Procedure definitions are not the only way to create procedures. A <code class="language-plaintext highlighter-rouge">lambda</code> expression creates a new procedure as an object, with no need to specify a name:</p>

<pre><code class="language-klipse-scheme">((lambda (x) (+ x 42)) 23)
</code></pre>

<p>The entire expression in this example is a procedure call: <code class="language-plaintext highlighter-rouge">(lambda (x) (+ x 42))</code>, evaluates to a procedure that takes a single number object and adds 42 to it.</p>

<h1 id="procedure-calls-and-syntactic-keywords">Procedure calls and syntactic keywords</h1>

<p>Whereas <code class="language-plaintext highlighter-rouge">(+ 23 42)</code>, <code class="language-plaintext highlighter-rouge">(f 23)</code>, and <code class="language-plaintext highlighter-rouge">((lambda (x) (+ x 42)) 23)</code> are all examples of procedure calls, <code class="language-plaintext highlighter-rouge">lambda</code> and <code class="language-plaintext highlighter-rouge">let</code> expressions are not. This is because <code class="language-plaintext highlighter-rouge">let</code>, even though it is an identifier, is not a variable, but is instead a syntactic keyword.</p>

<p>A form that has a syntactic keyword as its first subexpression obeys special rules determined by the keyword. The <code class="language-plaintext highlighter-rouge">define</code> identifier in a definition is also a syntactic keyword. Hence, definitions are also not procedure calls.</p>

<p>The rules for the <code class="language-plaintext highlighter-rouge">lambda</code> keyword specify that the first subform is a list of parameters, and the remaining subforms are the body of the procedure. In <code class="language-plaintext highlighter-rouge">let</code> expressions, the first subform is a list of binding specifications, and the remaining subforms constitute a body of expressions.</p>

<p>Procedure calls can generally be distinguished from these special forms by looking for a syntactic keyword in the first position of an form: if the first position does not contain a syntactic keyword, the expression is a procedure call. (So-called identifier macros allow creating other kinds of special forms, but are comparatively rare.)</p>

<p>The set of syntactic keywords of Scheme is fairly small, which usually makes this task fairly simple. It is possible, however, to create new bindings for syntactic keywords.</p>

<h1 id="assignment">Assignment</h1>

<p>Scheme variables bound by definitions or let or lambda expressions are not actually bound directly to the objects specified in the respective bindings, but to locations containing these objects. The contents of these locations can subsequently be modified destructively via assignment:</p>

<pre><code class="language-klipse-scheme">(let ((x 23))
  (set! x 42)
  x)
</code></pre>

<p>In this case, the body of the let expression consists of two expressions which are evaluated sequentially, with the value of the final expression becoming the value of the entire let expression. The expression <code class="language-plaintext highlighter-rouge">(set! x 42)</code> is an assignment, saying “replace the object in the location referenced by <code class="language-plaintext highlighter-rouge">x</code> with 42”. Thus, the previous value of <code class="language-plaintext highlighter-rouge">x</code>, 23, is replaced by 42.</p>

<h1 id="derived-forms-and-macros">Derived forms and macros</h1>

<p>Many of the special forms specified in this report can be translated into more basic special forms. For example, a let expression can be translated into a procedure call and a lambda expression. The following two expressions are equivalent:</p>

<pre><code class="language-klipse-scheme">(let ((x 23)
      (y 42))
  (+ x y))
</code></pre>

<pre><code class="language-klipse-scheme">((lambda (x y) (+ x y)) 23 42)
</code></pre>

<p>Special forms like <code class="language-plaintext highlighter-rouge">let</code> expressions are called derived forms because their semantics can be derived from that of other kinds of forms by a syntactic transformation. Some procedure definitions are also derived forms. The following two definitions are equivalent:</p>

<pre><code class="language-klipse-scheme">(define (f x)
  (+ x 42))
</code></pre>

<pre><code class="language-klipse-scheme">(define f
  (lambda (x)
    (+ x 42)))
</code></pre>

<p>In Scheme, it is possible for a program to create its own derived forms by binding syntactic keywords to macros:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define-syntax</span> <span class="nv">def</span>
  <span class="p">(</span><span class="k">syntax-rules</span> <span class="p">()</span>
    <span class="p">((</span><span class="nf">def</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">p</span> <span class="o">...</span><span class="p">)</span> <span class="nv">body</span><span class="p">)</span>
     <span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">p</span> <span class="o">...</span><span class="p">)</span>
       <span class="nv">body</span><span class="p">))))</span>
</code></pre></div></div>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">def</span> <span class="nv">f</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">42</span><span class="p">))</span>
</code></pre></div></div>

<p>The define-syntax construct specifies that a parenthesized structure matching the pattern <code class="language-plaintext highlighter-rouge">(def f (p ...) body)</code>, where <code class="language-plaintext highlighter-rouge">f</code>, <code class="language-plaintext highlighter-rouge">p</code>, and <code class="language-plaintext highlighter-rouge">body</code> are pattern variables, is translated to <code class="language-plaintext highlighter-rouge">(define (f p ...) body)</code>. Thus, the <code class="language-plaintext highlighter-rouge">def</code> form appearing in the example gets translated to:</p>

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">42</span><span class="p">))</span>
</code></pre></div></div>

<p>The ability to create new syntactic keywords makes Scheme extremely flexible and expressive, allowing many of the features built into other languages to be derived forms in Scheme.</p>

<h1 id="syntactic-data-and-datum-values">Syntactic data and datum values</h1>

<p>A subset of the Scheme objects is called datum values. These include booleans, number objects, characters, symbols, and strings as well as lists and vectors whose elements are data.</p>

<p>Each datum value may be represented in textual form as a syntactic datum, which can be written out and read back in without loss of information. A datum value may be represented by several different syntactic data. Moreover, each datum value can be trivially translated to a literal expression in a program by prepending a <code class="language-plaintext highlighter-rouge">'</code> to a corresponding syntactic datum:</p>

<pre><code class="language-klipse-scheme">'23
</code></pre>

<pre><code class="language-klipse-scheme">'#t
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">'</code> shown in the previous examples is not needed for representations of number objects or booleans.</p>

<pre><code class="language-klipse-scheme">'23
</code></pre>

<pre><code class="language-klipse-scheme">'#t
</code></pre>

<p>The syntactic datum <code class="language-plaintext highlighter-rouge">foo</code> represents a symbol with name <code class="language-plaintext highlighter-rouge">“foo”</code>, and <code class="language-plaintext highlighter-rouge">'foo</code> is a literal expression with that symbol as its value.</p>

<pre><code class="language-klipse-scheme">'foo
</code></pre>

<p><code class="language-plaintext highlighter-rouge">(1 2 3)</code> is a syntactic datum that represents a list with elements 1, 2, and 3, and <code class="language-plaintext highlighter-rouge">'(1 2 3)</code> is a literal expression with this list as its value.</p>

<pre><code class="language-klipse-scheme">'(1 2 3)
</code></pre>

<p>Likewise, <code class="language-plaintext highlighter-rouge">#(1 2 3)</code> is a syntactic datum that represents a vector with elements 1, 2 and 3, and ‘#(1 2 3) is the corresponding literal.</p>

<pre><code class="language-klipse-scheme">'#(1 2 3)
</code></pre>

<p>The syntactic data are a superset of the Scheme forms. Thus, data can be used to represent Scheme forms as data objects. In particular, symbols can be used to represent identifiers.</p>

<pre><code class="language-klipse-scheme">'(+ 23 42)
</code></pre>

<pre><code class="language-klipse-scheme">'(define (f x) (+ x 42))
</code></pre>

<p>This facilitates writing programs that operate on Scheme source code, in particular interpreters and program transformers.</p>

<h1 id="continuations">Continuations</h1>

<p>Whenever a Scheme expression is evaluated there is a continuation wanting the result of the expression. The continuation represents an entire (default) future for the computation.</p>

<p>For example, informally the continuation of 3 in the expression <code class="language-plaintext highlighter-rouge">(+ 1 3)</code> adds 1 to it.</p>

<p>Normally these ubiquitous continuations are hidden behind the scenes and programmers do not think much about them. On rare occasions, however, a programmer may need to deal with continuations explicitly.</p>

<p>The <code class="language-plaintext highlighter-rouge">call-with-current-continuation</code> procedure allows Scheme programmers to do that by creating a procedure that reinstates the current continuation. The <code class="language-plaintext highlighter-rouge">call-with-current-continuation</code> procedure accepts a procedure, calls it immediately with an argument that is an escape procedure. This escape procedure can then be called with an argument that becomes the result of the call to <code class="language-plaintext highlighter-rouge">call-with-current-continuation</code>. That is, the escape procedure abandons its own continuation, and reinstates the continuation of the call to <code class="language-plaintext highlighter-rouge">call-with-current-continuation</code>.</p>

<p>In the following example, an escape procedure representing the continuation that adds 1 to its argument is bound to escape, and then called with 3 as an argument. The continuation of the call to escape is abandoned, and instead the 3 is passed to the continuation that adds 1:</p>

<pre><code class="language-klipse-scheme">(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3))))) 
</code></pre>

<p>An escape procedure has unlimited extent: It can be called after the continuation it captured has been invoked, and it can be called multiple times. This makes call-with-current-continuation significantly more powerful than typical non-local control constructs such as exceptions in other languages.</p>

<h1 id="conclusion">Conclusion</h1>

<p>If you like it, go ahead an provide in the comments some examples of cool code in Scheme. For instance, I’m really curious to see a real-life application of the <code class="language-plaintext highlighter-rouge">call-with-current-continuation</code>…</p>

        </div>
        <footer class="post-footer">
            <div class="separator"></div>
            <div class="post-share">
                <span class="post-share-title">Share:</span>
                <a target="_blank"
                    href="https://twitter.com/share?text=Interactive+overview+of+Scheme%27s+semantics&amp;url=https://blog.klipse.techscheme/2016/09/11/scheme-tutorial-1.html">Twitter</a>
                <a target="_blank"
                    href="https://www.facebook.com/sharer/sharer.php?u=https://blog.klipse.techscheme/2016/09/11/scheme-tutorial-1.html">Facebook</a>
            </div><!-- .share-post -->
        </footer>
    </article>

    
    <section class="newsletter-box inner">
    <h2 class="newsletter-box-title">Subscribe to Yehonathan Sharvit newsletter</h2>
    <p>Get the latest and greatest from Yehonathan Sharvit delivered straight to your inbox every week.</p>
    <!-- Begin TinyLetter Signup Form -->
    <div id="tinyletter_embed_signup">
      <form class="validate gh-subscribe-form" action="https://tinyletter.com/klipse" method="post" target="popupwindow" onsubmit="window.open('https://tinyletter.com/klipse', 'popupwindow', 'scrollbars=yes,width=800,height=600');return true">
	      <label for="tlemail" class="screen-reader-text">Email Address</label>
        <input type="email" value="" name="email" class="required email subscribe-email" placeholder="Your email address">
	      <input type="hidden" value="1" name="embed"/>
	      <input class="button" type="submit" value="Subscribe" />
      </form>
    </div>
    <!--End mc_embed_signup-->
</section><!-- .widget -->

    
    <section class="read-next inner">
        <h2 class="read-next-title">Read Next</h2>
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="September 9, 2016">September 9, 2016</time>
                </div>
                <h3 class="post-title"><a href="/klipse/2016/09/09/klipse-languages.html">Code playground in ruby, clojure, javascript, python, PHP and more</a>
                </h3>
                <p class="post-tags">
                    
                </p>
            </header>
        </article>
        
        
        <article class="post">
            <header class="post-header">
                <div class="post-meta">
                    <time class="published" datetime="September 16, 2016">September 16, 2016</time>
                </div>
                <h3 class="post-title"><a href="/clojure/2016/09/16/combinatorics-riddle.html">Solving a not-so-easy riddle with clojure.math.combinatorics</a></h3>
                <p class="post-tags">
                    
                    
                    
                    <a href='/tag/clojure/'>Clojure</a>
                    
                    
                    
                </p>
            </header>
        </article>
        
    </section><!-- .read-next -->

    <!-- Create a sorted array of tags -->
     
    <section class="tagcloud inner">
        <h2 class="tagcloud-title">Tags</h2>
        <div class="tag-links">
            
            <a href='/tags/#algo'>algo</a>
            
            <a href='/tags/#brainfuck'>brainfuck</a>
            
            <a href='/tags/#c%2B%2B'>c++</a>
            
            <a href='/tags/#clojure'>clojure</a>
            
            <a href='/tags/#clojurescript'>clojurescript</a>
            
            <a href='/tags/#compiler'>compiler</a>
            
            <a href='/tags/#dop'>dop</a>
            
            <a href='/tags/#golang'>golang</a>
            
            <a href='/tags/#graph'>graph</a>
            
            <a href='/tags/#html'>html</a>
            
            <a href='/tags/#java'>java</a>
            
            <a href='/tags/#javascript'>javascript</a>
            
            <a href='/tags/#kids'>kids</a>
            
            <a href='/tags/#klipse'>klipse</a>
            
            <a href='/tags/#lambda-calculus'>lambda-calculus</a>
            
            <a href='/tags/#lambdacalculus'>lambdacalculus</a>
            
            <a href='/tags/#lisp'>lisp</a>
            
            <a href='/tags/#lua'>lua</a>
            
            <a href='/tags/#maths'>maths</a>
            
            <a href='/tags/#oblivion'>oblivion</a>
            
            <a href='/tags/#ocaml'>ocaml</a>
            
            <a href='/tags/#php'>php</a>
            
            <a href='/tags/#prolog'>prolog</a>
            
            <a href='/tags/#python'>python</a>
            
            <a href='/tags/#react'>react</a>
            
            <a href='/tags/#reagent'>reagent</a>
            
            <a href='/tags/#reasonml'>reasonml</a>
            
            <a href='/tags/#ruby'>ruby</a>
            
            <a href='/tags/#scheme'>scheme</a>
            
            <a href='/tags/#sql'>sql</a>
            
            <a href='/tags/#theory'>theory</a>
            
            <a href='/tags/#visualization'>visualization</a>
            
        </div><!-- .tag-links -->
    </section><!-- .tagcloud -->
</main><!-- .site-main -->


<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/prolog.css">

<script>
    window.klipse_settings = {
        codemirror_options_in: {
            lineWrapping: true,
            autoCloseBrackets: true
        },
        codemirror_options_out: {
            lineWrapping: true
        },
        beautify_strings: true,

        selector: '.language-klipse, .language-eval-clj',
        selector_eval_js: '.language-klipse-eval-js, .language-eval-js, [data-lang=klipse-javascript]',
        selector_jsx: '.language-klipse-jsx',
        selector_prolog_rules: '.language-prolog-rules',
        selector_prolog_query: '.language-prolog-query',
        selector_render_jsx: '.language-render-jsx',
        selector_es2017: '.language-es2017',
        selector_brainfuck: '.language-brainfuck',
        selector_transpile_jsx: '.language-transpile-jsx',
        selector_eval_php: '.language-klipse-eval-php',
        selector_eval_markdown: '.language-klipse-markdown',
        selector_eval_lambdaway: '.language-klipse-lambdaway',
        selector_eval_python_client: '.language-klipse-python, .language-eval-python',
        selector_eval_html: '.language-klipse-html',
        selector_sql: '.language-klipse-sql',
        selector_eval_ruby: '.language-klipse-eval-ruby, .language-eval-ruby',
        selector_eval_scheme: '.language-klipse-scheme, .language-eval-scheme',
        selector_eval_clisp: '.language-klipse-clisp',    
        selector_eval_cpp: '.language-klipse-cpp',
        selector_google_charts: '.language-google-chart',
        selector_plot: '.language-plot',
        selector_oblivion: '.language-oblivion',
        selector_lua: '.language-klipse-lua',
        selector_js: '.language-klipse-js',
        selector_eval_ocaml: '.language-klipse-ocaml',
        selector_transpile_ocaml: '.language-transpile-ocaml',
        selector_transpile_reason_3: '.language-transpile-reason',
        selector_transpile_reason_3_to_ocaml: '.language-transpile-reason-to-ocaml',
        selector_eval_reason_3: '.language-klipse-reason',
        selector_eval_reason_3_with_types: '.language-klipse-reason-types',
        selector_eval_ocaml_with_types: '.language-klipse-ocaml-types',
        selector_ocaml_to_reason: '.language-ocaml-to-reason',
        selector_reagent: '.language-reagent',
        selector_golang: '.language-klipse-go',
    };










    

    


</script>



<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js?v=8.0.1"></script>





                

                
                <footer id="colophon" class="site-footer">
    <p class="site-info inner">
        <a href="#">Yehonathan Sharvit</a> &copy; 2021.
    </p>
    <a id="back-to-top" class="back-to-top" href="#page">
        <span class="icon-arrow-up" aria-hidden="true"></span>
        <span class="screen-reader-text">Back to top</span>
    </a>
</footer><!-- .site-footer -->

            </div><!-- .inner-wide -->
        </div><!-- .site-content -->
    </div><!-- .site -->

    
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-75651930-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-75651930-1', { 'anonymize_ip': true });
  </script>

    <!-- Javascript Assets -->
    <script src="/assets/js/jquery-3.3.1.min.js"></script>
    <script src="/assets/js/plugins.js"></script>
    <script src="/assets/js/custom.js"></script>

</body>

</html>
